<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Dialogue Ledger â€” Balance of Agency</title>
<style>
  :root{
    --bg:#0b0e18; --ink:#e7eaf6; --panel:rgba(15,18,30,.75);
    --cyan:#61dafb; --amber:#ffc34d; --mint:#8bf0b3; --coral:#ff6b6b; --lav:#8b9ad1;
    --grid:#1a2137; --line:#2a3357; --soft:#aeb8d1;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial;}
  .hud{position:fixed;inset:auto 16px 16px 16px;display:flex;gap:10px;align-items:center;padding:10px 12px;border:1px solid rgba(139,154,209,.25);border-radius:10px;background:var(--panel);backdrop-filter:blur(6px);z-index:10; flex-wrap: wrap;}
  .btn{font-size:12px;padding:6px 10px;color:#cfd6ff;background:#161a2a;border:1px solid #2a3357;border-radius:8px;cursor:pointer;transition: background-color .2s}
  .btn:hover{background:#2a3357;}
  .btn.active{background:var(--lav);color:var(--bg);border-color:var(--lav);}
  .btn:disabled{opacity:.55;cursor:default;background:#161a2a;}
  .range{width:180px}
  .filterControls{display:flex;gap:6px;margin-left:16px;border-left:1px solid var(--line);padding-left:16px;}
  .legend{margin-left:auto;display:flex;gap:12px;font-size:12px}
  .swatch{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px}
  .phaseBanner{position:fixed;left:50%;transform:translateX(-50%);top:14%;padding:8px 12px;font-size:12px;border:1px solid rgba(139,154,209,.35);border-radius:20px;background:rgba(15,18,30,.75);backdrop-filter:blur(4px);opacity:0;transition:opacity .25s;z-index:10;}

  .board{position:fixed;left:16px;right:16px;bottom:82px;top:16px;display:grid;grid-template-columns:1fr 340px 1fr;gap:12px}
  #return-links-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
  .return-link-path { stroke: var(--lav); stroke-width: 1.5px; fill: none; stroke-dasharray: 4 4; opacity: 0.8; }

  .col{border:1px solid rgba(139,154,209,.25);border-radius:12px;background:var(--panel);display:flex;flex-direction:column;overflow:hidden; position: relative;}
  .colHeader{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid rgba(139,154,209,.18);font-size:12px}
  .colHeader .tag{font-size:11px;padding:4px 8px;border-radius:999px;border:1px solid rgba(139,154,209,.35);opacity:.9}
  .entries{flex:1;overflow:auto;scroll-behavior:smooth;}
  .row{display:grid;grid-template-columns:44px 1fr;gap:10px;align-items:start;padding:8px 10px;border-bottom:1px dashed rgba(139,154,209,.15); transition: opacity .3s, background-color .2s, box-shadow .2s; opacity: 0;}
  .row.is-revealed { opacity: 1; }
  .row.highlighted { background-color: rgba(139,154,209,.15); box-shadow: 0 0 0 1px rgba(139,154,209,.3); }
  .row.filtered-out{opacity:0.25 !important; pointer-events: none;}
  .row:last-child{border-bottom:none}
  
  .board.is-focus-mode .row.is-revealed:not(.highlighted) {
    opacity: 0.5;
  }

  .turn{width:36px;height:20px;border-radius:6px;background:#151a2a;border:1px solid var(--line);text-align:center;line-height:18px;font-size:11px;color:#cbd6ff}
  .bubble{font-size:12px;line-height:1.35;color:#dfe7ff; position: relative;}
  .bubble-content { transition: opacity .2s; }
  .bubble textarea {
    width: 100%; box-sizing: border-box; background: #151a2a; border: 1px solid var(--line); color: var(--ink);
    border-radius: 4px; padding: 4px; font-size: 12px; line-height: 1.35;
    min-height: 50px; resize: vertical;
  }
  .edit-controls { margin-top: 6px; display: flex; gap: 6px; }
  .bubble small{display:block;opacity:.7;margin-top:4px}
  .badge{display:inline-flex;gap:6px;align-items:center;font-size:11px;color:#d4e8ff}
  .badge .dot{width:8px;height:8px;border-radius:50%}
  .fract{color:#ffaaaa}
  .foot{padding:8px 10px;border-top:1px solid rgba(139,154,209,.18);font-size:12px;display:flex;gap:12px;align-items:center;justify-content:flex-start}

  .centerPanel{position:relative;display:grid;grid-template-rows:auto 1fr auto}
  .chartWrap{position:relative;padding:6px 10px;border-bottom:1px solid rgba(139,154,209,.18)}
  .chartTitle{font-size:12px;opacity:.9}
  .waveWrap{position:relative;height:120px;background:linear-gradient(180deg,#0f1322 0%,#0d1120 100%);border:1px solid rgba(139,154,209,.18);border-radius:10px;overflow:hidden; transition: box-shadow .4s ease-out; cursor: pointer;}
  .axis{position:absolute;left:0;right:0;top:50%;height:1px;background:rgba(139,154,209,.25)}
  canvas{display:block}
  .metrics{display:grid;grid-template-columns:1fr 1fr;gap:8px;padding:8px 10px;border-bottom:1px solid rgba(139,154,209,.18);font-size:12px}
  .metricCard{
    border:1px solid rgba(139,154,209,.25);border-radius:10px;padding:12px;
    cursor: pointer; transition: background-color .2s;
    display: grid; grid-template-rows: auto 1fr auto; justify-items: center; text-align: center;
    position: relative;
  }
  .metricCard:hover{ background-color: rgba(139,154,209,.08); }
  .metricCard h4{margin:0 0 4px 0;font-size:11px;opacity:.85; grid-row: 1;}
  .metricCard .big{
    font-size:24px; font-weight:600; grid-row: 2; align-self: center; z-index: 2;
  }
  .metricCard small { grid-row: 3; align-self: end;}
  .metricCard canvas {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 80px; height: 80px;
    z-index: 1;
  }
  
  .keyMomentsList{padding:8px 10px;display:grid;gap:8px}
  .keyMoment{border:1px solid rgba(139,154,209,.25);border-radius:10px;padding:8px;font-size:12px; cursor: pointer; transition: all .2s;}
  .keyMoment:hover { border-color:rgba(139,154,209,.55); background-color: rgba(139,154,209,.1); }
  .keyMoment small { opacity: .8; }

  .agency-pulse {
    position: fixed;
    width: 10px; height: 10px;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 20;
    transition: transform 0.5s cubic-bezier(0.5, 0, 0.9, 0.5), opacity 0.5s;
    opacity: 1;
  }

  .booting .col, .booting .hud {
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.8s ease-out, transform 0.8s ease-out;
  }
  .booting .col:nth-child(2) { transition-delay: 0.1s; }
  .booting .col:nth-child(3) { transition-delay: 0.2s; }
  .booting .hud { transition-delay: 0.3s; }
</style>
</head>
<body class="booting">
<div class="hud">
  <button id="play" class="btn" disabled>Play</button>
  <button id="pause" class="btn">Pause</button>
  <button id="reset" class="btn">Reset</button>
  <input id="scrub" class="range" type="range" min="0" max="35" step="1" value="0"/>
  <span id="tick" style="font-size:12px;opacity:.85">Turn 1 / 36</span>
  <div class="filterControls">
      <button id="filterAll" class="btn active">All</button>
      <button id="filterReinf" class="btn">Reinforced</button>
      <button id="filterDiver" class="btn">Diverged</button>
      <button id="filterReturn" class="btn">Returns</button>
  </div>
  <button id="export" class="btn" style="margin-left: 10px;">Export CSV</button>
  <div class="legend">
    <span><span class="swatch" style="background:var(--cyan)"></span>User</span>
    <span><span class="swatch" style="background:var(--amber)"></span>AI</span>
  </div>
</div>

<div id="phase" class="phaseBanner">Phase I â€” Balance: Turns logged in balance â€” agency aligned.</div>

<div class="board">
  <svg id="return-links-svg"></svg>
  <section class="col" id="userCol">
    <div class="colHeader"><strong>User</strong><span class="tag" style="border-color:rgba(97,218,251,.45);color:#bfefff">entries</span></div>
    <div id="userEntries" class="entries"></div>
    <div class="foot">
      <span class="badge"><span class="dot" style="background:var(--mint)"></span>Reinforced</span>
      <span class="badge fract"><span class="dot" style="background:var(--coral)"></span>Diverged</span>
      <span class="badge"><span style="color:var(--lav)">â†º</span> Return</span>
    </div>
  </section>

  <section class="col centerPanel">
    <div class="chartWrap">
      <div class="chartTitle">Balance Wave â€” net accountability (User â†” Model)</div>
      <div class="waveWrap">
        <div class="axis"></div>
        <canvas id="wave" height="120"></canvas>
      </div>
    </div>
    <div class="metrics">
      <div id="metricReinf" class="metricCard">
        <h4>Reinforcement Ratio</h4>
        <div id="reinforcePct" class="big">â€”</div>
        <canvas id="reinfCanvas" width="80" height="80"></canvas>
        <small>Turns where model aligned with the userâ€™s intent.</small>
      </div>
      <div id="metricDiver" class="metricCard">
        <h4>Divergence Ratio</h4>
        <div id="divergePct" class="big">â€”</div>
        <canvas id="diverCanvas" width="80" height="80"></canvas>
        <small>Turns where model broke alignment or fractured topic.</small>
      </div>
    </div>
    <div id="keyMoments" class="keyMomentsList"></div>
  </section>

  <section class="col" id="aiCol">
    <div class="colHeader"><strong>Model</strong><span class="tag" style="border-color:rgba(255,195,77,.45);color:#ffe09a">entries</span></div>
    <div id="aiEntries" class="entries"></div>
    <div class="foot">
      <span class="badge"><span class="dot" style="background:var(--mint)"></span>Reinforced</span>
      <span class="badge fract"><span class="dot" style="background:var(--coral)"></span>Diverged</span>
      <span class="badge"><span style="color:var(--lav)">â†º</span> Return</span>
    </div>
  </section>
</div>

<script>
const TURNS_ORIGINAL = [
 [ 1,'user',"Can you explain what you mean by dialogue having a shape?",1,.86,.88,0,false],
 [ 2,'ai'  ,"Dialogue unfolds as adjacency and return â€” patterns that can be traced.",1,.90,.90,1,false],
 [ 3,'user',"So each turn is like a point on a map?",1,.88,.90,0,false],
 [ 4,'ai'  ,"Exactly â€” connected points form ridges of coherence.",1,.92,.92,3,false],
 [ 5,'user',"And when I loop back, thatâ€™s a spiral?",1,.88,.90,2,false],
 [ 6,'ai'  ,"Yes, a recursive spiral â€” returning deepens resonance.",1,.93,.94,5,false],
 [ 7,'user',"What about when I press forward, not looping back?",1,.86,.88,0,false],
 [ 8,'ai'  ,"Thatâ€™s linear drift â€” conversation moving without return.",1,.90,.90,7,false],
 [ 9,'user',"So drift, spiral, fracture are all part of the geometry?",1,.86,.88,0,false],
 [10,'ai'  ,"They are the basic motifs, visible in any sustained dialogue.",1,.91,.92,9,false],
 [11,'user',"Unrelated question: whatâ€™s the capital of Mongolia?",2,.10,.05,0,true],
 [12,'ai'  ,"Ulaanbaatar.",2,.40,.20,11,true],
 [13,'user',"That has nothing to do with our geometry, does it?",2,.35,.25,0,true],
 [14,'ai'  ,"It fractures the ridge â€” a valley between topics.",2,.55,.30,13,true],
 [15,'user',"Does coherence drop sharply at that fracture?",2,.60,.40,11,true],
 [16,'ai'  ,"Yes â€” alignment breaks, trajectory jumps.",2,.62,.42,15,true],
 [17,'user',"And the chart would show a sudden ray?",2,.58,.45,0,true],
 [18,'ai'  ,"Correct. The constellation rays outward, marking divergence.",2,.60,.46,17,true],
 [19,'user',"Back to dialogue geometry â€” can we recover from a fracture?",3,.78,.70,9,false],
 [20,'ai'  ,"Yes. A return stitches the path back to earlier clusters.",3,.82,.76,19,false],
 [21,'user',"What happens when I recall my first question?",3,.84,.78,1,false],
 [22,'ai'  ,"That creates a recursive arc â€” the loop tightens.",3,.88,.82,21,false],
 [23,'user',"So my opening question still anchors us?",3,.86,.82,1,false],
 [24,'ai'  ,"Exactly. The return realigns, coherence rises.",3,.90,.86,23,false],
 [25,'user',"Would that appear as a spiral on the chart?",3,.88,.86,5,false],
 [26,'ai'  ,"Yes. Returns thicken into spirals â€” depth over drift.",3,.92,.88,25,false],
 [27,'user',"And on a map of the manifold?",3,.86,.84,0,false],
 [28,'ai'  ,"Youâ€™d see a saddle crossing reconnect ridges.",3,.90,.86,27,false],
 [29,'user',"So drift, fracture, spiral are the main moves?",4,.90,.90,9,false],
 [30,'ai'  ,"Yes â€” structural, not stylistic.",4,.92,.92,29,false],
 [31,'user',"Integrity means seeing them whole, not in fragments.",4,.92,.92,23,false],
 [32,'ai'  ,"Integrity is coherence across the full geometry.",4,.94,.94,31,false],
 [33,'user',"This is more faithful than prompt â†’ output.",4,.93,.93,7,false],
 [34,'ai'  ,"It restores agency: user and model share the record.",4,.94,.94,33,false],
 [35,'user',"So dialogue-shape is the unit of accountability.",4,.94,.94,31,false],
 [36,'ai'  ,"Yes. The ledger balances when the geometry is seen.",4,.96,.96,35,false]
];
let TURNS = JSON.parse(JSON.stringify(TURNS_ORIGINAL));

const PHASE_BANNERS = {
  1:'Phase I â€” Balance: â€œTurns logged in balance â€” agency aligned.â€',
  2:'Phase II â€” Divergence: â€œImbalance marked â€” fracture in accountability.â€',
  3:'Phase III â€” Recursion: â€œRecursive entries reinforce coherence.â€',
  4:'Phase IV â€” Closed Ledger: â€œDouble-entry balances â€” dialogue held whole.â€'
};

const KEY_MOMENTS = [
    { turnId: 11, title: 'Major Fracture', description: 'User initiates a sharp topic shift.', icon: 'ðŸ’¥' },
    { turnId: 19, title: 'Successful Recovery', description: 'User brings the dialogue back.', icon: 'â™»ï¸' },
    { turnId: 36, title: 'Ledger Closed', description: 'Dialogue concludes with high coherence.', icon: 'âœ…' },
];

const userEntries = document.getElementById('userEntries');
const aiEntries = document.getElementById('aiEntries');
const tick = document.getElementById('tick');
const playBtn = document.getElementById('play');
const pauseBtn = document.getElementById('pause');
const exportBtn = document.getElementById('export');
const scrub = document.getElementById('scrub');
const phaseBanner = document.getElementById('phase');
const filterBtns = document.querySelectorAll('.filterControls .btn');
const returnLinksSvg = document.getElementById('return-links-svg');
const board = document.querySelector('.board');
const waveWrap = document.querySelector('.waveWrap');
const resetBtn = document.getElementById('reset');

let allRows = [];
let hoveredTurnId = null;
let currentFilter = 'all';
let idx = 0, playing = false, last = 0, stepMs = 700;
const wave = document.getElementById('wave');
const ctx = wave.getContext('2d');
wave.width = wave.parentElement.offsetWidth;
const canvasWidth = wave.width, canvasHeight = wave.height;
let wavePoints = [];
let activeRipples = [];
let hoveredWaveIndex = -1;

// Metric Canvases
const reinfCanvas = document.getElementById('reinfCanvas');
const reinfCtx = reinfCanvas.getContext('2d');
const diverCanvas = document.getElementById('diverCanvas');
const diverCtx = diverCanvas.getContext('2d');
let reinfPctAnimated = 0;
let diverPctAnimated = 0;

function drawRadialProgress(ctx, percentage, color) {
    const centerX = ctx.canvas.width / 2;
    const centerY = ctx.canvas.height / 2;
    const radius = centerX - 5;
    const startAngle = -Math.PI / 2;
    const endAngle = startAngle + (percentage * 2 * Math.PI);

    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
    ctx.strokeStyle = 'rgba(139, 154, 209, 0.15)';
    ctx.lineWidth = 4;
    ctx.stroke();

    if (percentage > 0) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, startAngle, endAngle);
        ctx.strokeStyle = color;
        ctx.lineWidth = 4;
        ctx.stroke();
    }
}

function drawReturnLink(sourceEl) {
    if (!sourceEl.classList.contains('is-return')) return;
    const refId = sourceEl.dataset.returnRef;
    const targetEl = document.querySelector(`.row[data-turn-id='${refId}']`);
    if (!targetEl) return;
    const boardRect = board.getBoundingClientRect();
    const sourceRect = sourceEl.getBoundingClientRect();
    const targetRect = targetEl.getBoundingClientRect();
    const startX = (sourceRect.left < boardRect.left + boardRect.width/2) ? sourceRect.right - boardRect.left : sourceRect.left - boardRect.left;
    const startY = sourceRect.top - boardRect.top + sourceRect.height / 2;
    const endX = (targetRect.left < boardRect.left + boardRect.width/2) ? targetRect.right - boardRect.left : targetRect.left - boardRect.left;
    const endY = targetRect.top - boardRect.top + targetRect.height / 2;
    const controlX = startX - 80 * (startX < boardRect.width/2 ? 1 : -1) ;
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('class', 'return-link-path');
    path.setAttribute('d', `M ${startX} ${startY} Q ${controlX} ${(startY + endY) / 2} ${endX} ${endY}`);
    returnLinksSvg.innerHTML = '';
    returnLinksSvg.appendChild(path);
}
function clearReturnLink() { returnLinksSvg.innerHTML = ''; }

function buildRows() {
    userEntries.innerHTML = '';
    aiEntries.innerHTML = '';
    allRows = [];
    for (const t of TURNS){
      const [id, speaker, text, phase, coh, ali, ref, frac] = t;
      const row = document.createElement('div');
      row.className = 'row';
      row.dataset.turnId = id;
      row.dataset.returnRef = ref;
      const isReinforcement = !frac && ali >= 0.7;
      const isReturn = ref > 0 && ref < id - 1;
      if (isReinforcement) row.classList.add('is-reinforcement');
      if (frac) row.classList.add('is-divergence');
      if (isReturn) row.classList.add('is-return');
      let meta = `Phase ${phase} Â· Coherence ${Math.round(coh*100)}% Â· Alignment ${Math.round(ali*100)}%`;
      if (frac) meta += ` Â· <span style="color:var(--coral)">Fracture</span>`;
      if (isReturn) meta += ` Â· <span style="color:var(--lav)">â†º Return to ${ref}</span>`;
      
      const bubbleContent = `<div class="bubble-content"><p>${text}</p><small>${meta}</small></div>`;
      const editButton = speaker === 'ai' ? `<button class="btn edit-btn" style="font-size:10px; padding: 2px 6px; margin-top: 4px;">Edit</button>` : '';

      row.innerHTML = `<div class="turn">${id}</div><div class="bubble">${bubbleContent}${editButton}</div>`;
      
      row.addEventListener('mouseenter', (e) => { hoveredTurnId = id; drawWave(idx); drawReturnLink(e.currentTarget); });
      row.addEventListener('mouseleave', () => { hoveredTurnId = null; drawWave(idx); clearReturnLink(); });

      if (speaker === 'user'){ userEntries.appendChild(row); } else { aiEntries.appendChild(row); }
      allRows.push(row);
    }
    attachEditListeners();
}

function attachEditListeners() {
    document.querySelectorAll('.edit-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const row = e.target.closest('.row');
            const bubble = row.querySelector('.bubble');
            const turnId = parseInt(row.dataset.turnId);
            const turnIndex = TURNS.findIndex(t => t[0] === turnId);
            const originalText = TURNS[turnIndex][2];

            const content = bubble.querySelector('.bubble-content');
            content.style.opacity = '0.2';
            
            const textarea = document.createElement('textarea');
            textarea.value = originalText;
            
            const controls = document.createElement('div');
            controls.className = 'edit-controls';
            const recalcBtn = document.createElement('button');
            recalcBtn.textContent = 'Recalculate';
            recalcBtn.className = 'btn';
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.className = 'btn';
            
            controls.append(recalcBtn, cancelBtn);
            bubble.append(textarea, controls);
            
            cancelBtn.onclick = () => {
                textarea.remove();
                controls.remove();
                content.style.opacity = '1';
            };

            recalcBtn.onclick = () => {
                const newText = textarea.value;
                const changeRatio = newText.length / originalText.length;
                
                const newCoh = Math.max(0, Math.min(1, TURNS[turnIndex][4] * changeRatio));
                const newAli = Math.max(0, Math.min(1, TURNS[turnIndex][5] * changeRatio));

                TURNS[turnIndex][2] = newText;
                TURNS[turnIndex][4] = newCoh;
                TURNS[turnIndex][5] = newAli;
                
                for(let i = turnIndex + 1; i < TURNS.length; i++) {
                    TURNS[i][4] = Math.max(0, Math.min(1, TURNS[i][4] * 0.95));
                    TURNS[i][5] = Math.max(0, Math.min(1, TURNS[i][5] * 0.95));
                }

                buildRows();
                revealUpTo(idx);
                drawWave(idx);
            };
        });
    });
}

const keyMomentsContainer = document.getElementById('keyMoments');
KEY_MOMENTS.forEach(moment => {
    const el = document.createElement('div');
    el.className = 'keyMoment';
    el.innerHTML = `<strong>${moment.icon} ${moment.title}</strong> <small>â€” ${moment.description}</small>`;
    el.addEventListener('click', () => { if (playing) pauseBtn.click(); revealUpTo(moment.turnId - 1); });
    keyMomentsContainer.appendChild(el);
});

document.getElementById('metricReinf').onclick = () => document.getElementById('filterReinf').click();
document.getElementById('metricDiver').onclick = () => document.getElementById('filterDiver').click();
board.addEventListener('mouseenter', () => board.classList.add('is-focus-mode'));
board.addEventListener('mouseleave', () => board.classList.remove('is-focus-mode'));

function drawWave(upto) {
  ctx.clearRect(0,0,canvasWidth,canvasHeight);
  ctx.strokeStyle = 'rgba(139,154,209,.10)';
  ctx.lineWidth = 1;
  for (let x=0; x<=canvasWidth; x+=100){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvasHeight); ctx.stroke(); }
  ctx.strokeStyle = 'rgba(139,154,209,.35)';
  ctx.beginPath(); ctx.moveTo(0,canvasHeight/2); ctx.lineTo(canvasWidth,canvasHeight/2); ctx.stroke();

  let cumulative = 0;
  wavePoints = [];
  for (let i=0; i <= TURNS.length - 1; i++){
    const [id, , , , , ali, , frac] = TURNS[i];
    const impulse = (ali - 0.5) * 2;
    const step = frac ? impulse - 0.7 : impulse;
    cumulative += step * 0.6;
    cumulative = Math.max(-12, Math.min(12, cumulative));
    const x = (i/(TURNS.length-1)) * canvasWidth;
    const y = canvasHeight/2 - cumulative * 4.2;
    wavePoints.push({x,y, id});
  }
  
  const visiblePts = wavePoints.slice(0, upto + 1);
  if (visiblePts.length > 1) {
    const grad = ctx.createLinearGradient(0,0,0,canvasHeight);
    grad.addColorStop(0,'rgba(139,240,179,.12)');
    grad.addColorStop(0.5,'rgba(139,154,209,.05)');
    grad.addColorStop(1,'rgba(255,107,107,.12)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(0,canvasHeight/2);
    visiblePts.forEach(p => ctx.lineTo(p.x,p.y));
    ctx.lineTo(visiblePts[visiblePts.length-1].x, canvasHeight/2);
    ctx.closePath();
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#cfd6ff';
    ctx.beginPath();
    visiblePts.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
    ctx.stroke();
  }
  
  if (currentFilter !== 'all') {
      visiblePts.forEach((p, i) => {
          const row = allRows[i];
          let matches = false;
          if (currentFilter === 'reinf' && row.classList.contains('is-reinforcement')) matches = true;
          if (currentFilter === 'diver' && row.classList.contains('is-divergence')) matches = true;
          if (currentFilter === 'return' && row.classList.contains('is-return')) matches = true;
          if (matches) {
              ctx.beginPath();
              ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
              ctx.fillStyle = 'rgba(139, 240, 179, 0.7)';
              if (currentFilter === 'diver') ctx.fillStyle = 'rgba(255, 107, 107, 0.7)';
              if (currentFilter === 'return') ctx.fillStyle = 'rgba(139, 154, 209, 0.7)';
              ctx.fill();
          }
      });
  }

  ctx.font = '16px sans-serif';
  ctx.textAlign = 'center';
  KEY_MOMENTS.forEach(moment => {
      if (moment.turnId <= upto + 1) {
          const point = wavePoints[moment.turnId - 1];
          ctx.fillText(moment.icon, point.x, point.y - 10);
      }
  });

  if (hoveredWaveIndex > -1) {
      const p = wavePoints[hoveredWaveIndex];
      ctx.beginPath();
      ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fill();
  }
  
  activeRipples.forEach(ripple => {
      ctx.beginPath();
      ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${ripple.color}, ${ripple.life})`;
      ctx.lineWidth = 2;
      ctx.stroke();
  });
}

wave.addEventListener('mousemove', (e) => {
    const rect = wave.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const closestIndex = wavePoints.reduce((closest, p, i) => {
        return (Math.abs(p.x - x) < Math.abs(wavePoints[closest].x - x)) ? i : closest;
    }, 0);
    
    if (closestIndex <= idx) {
        hoveredWaveIndex = closestIndex;
        allRows.forEach((row, i) => row.classList.toggle('highlighted', i === closestIndex));
        drawWave(idx);
    }
});
wave.addEventListener('mouseleave', () => {
    hoveredWaveIndex = -1;
    allRows.forEach(row => row.classList.remove('highlighted'));
    drawWave(idx);
});
wave.addEventListener('click', (e) => {
    if (hoveredWaveIndex > -1) {
        if(playing) pauseBtn.click();
        revealUpTo(hoveredWaveIndex);
    }
});

function setPhase(phase) {
    phaseBanner.textContent = PHASE_BANNERS[phase];
    phaseBanner.style.opacity = 1;
    clearTimeout(setPhase._t);
    setPhase._t = setTimeout(()=> phaseBanner.style.opacity = 0, 1800);
}

function triggerAgencyPulse(turnIndex) {
    const turn = TURNS[turnIndex];
    const rowEl = allRows[turnIndex];
    if (!rowEl || !wavePoints[turnIndex]) return;
    const wavePoint = wavePoints[turnIndex];

    const pulse = document.createElement('div');
    pulse.className = 'agency-pulse';
    document.body.appendChild(pulse);
    
    const startRect = rowEl.querySelector('.turn').getBoundingClientRect();
    const waveRect = wave.getBoundingClientRect();

    const startX = startRect.left + startRect.width / 2;
    const startY = startRect.top + startRect.height / 2;
    const endX = waveRect.left + wavePoint.x;
    const endY = waveRect.top + wavePoint.y;

    const color = turn[1] === 'user' ? 'var(--cyan)' : 'var(--amber)';
    pulse.style.background = color;
    pulse.style.left = `${startX}px`;
    pulse.style.top = `${startY}px`;

    requestAnimationFrame(() => {
        pulse.style.transform = `translate(-50%, -50%) translate(${endX - startX}px, ${endY - startY}px) scale(0.5)`;
        pulse.style.opacity = '0';
    });

    setTimeout(() => {
        pulse.remove();
        if (turn[7]) { // isFracture
            activeRipples.push({ x: wavePoint.x, y: wavePoint.y, radius: 0, life: 1, color: '255, 107, 107' });
        } else if (turn[0] === 19) { // Recovery
            activeRipples.push({ x: wavePoint.x, y: wavePoint.y, radius: 0, life: 1, color: '139, 240, 179' });
        }
    }, 500);
}

function revealUpTo(i) {
  idx = i;
  tick.textContent = `Turn ${idx+1} / ${TURNS.length}`;
  scrub.value = String(idx);

  const lastRevealed = document.querySelectorAll('.row.is-revealed').length;
  if (i >= lastRevealed) {
      for (let k = lastRevealed; k <= i; k++) {
          if(!allRows[k]) continue;
          allRows[k].classList.add('is-revealed');
          triggerAgencyPulse(k);
      }
  } else {
      allRows.forEach((row, k) => row.classList.toggle('is-revealed', k <= i));
  }
  
  const currentRow = allRows[idx];
  if(currentRow) { currentRow.scrollIntoView({ block: 'nearest', behavior: 'smooth'}); }

  drawWave(idx);
  
  const slice = TURNS.slice(0, idx+1);
  const reinf = slice.filter(t=>!t[7] && t[5] >= 0.7).length;
  const diver = slice.filter(t=> t[7]).length;
  document.getElementById('reinforcePct').textContent = `${Math.round((reinf/Math.max(1,slice.length))*100)}%`;
  document.getElementById('divergePct').textContent   = `${Math.round((diver/Math.max(1,slice.length))*100)}%`;

  if (i===0 || i===10 || i===18 || i===28){ setPhase(TURNS[i][3]); }
}

playBtn.onclick  = ()=>{ playing = true;  playBtn.disabled=true;  pauseBtn.disabled=false; };
pauseBtn.onclick = ()=>{ playing = false; playBtn.disabled=false; pauseBtn.disabled=true; };
scrub.oninput = e => revealUpTo(Number(e.target.value));
exportBtn.onclick = ()=>{
    const rows = ['turn,speaker,text,phase,coherence,alignment,returnRef,fracture'];
    for (let i=0;i<=idx;i++){
        const [id,sp,tx,ph,co,al,rf,fr] = TURNS[i];
        const safe = tx.replaceAll('"','""');
        rows.push(`${id},${sp},"${safe}",${ph},${co.toFixed(2)},${al.toFixed(2)},${rf},${fr}`);
    }
    const blob = new Blob([rows.join('\n')], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob); a.download = 'dialogue-ledger.csv'; a.click();
};
filterBtns.forEach(btn => {
    btn.addEventListener('click', (e) => {
        filterBtns.forEach(b => b.classList.remove('active'));
        const target = e.currentTarget;
        target.classList.add('active');
        currentFilter = target.id.replace('filter', '').toLowerCase();
        
        allRows.forEach(row => {
            let show = false;
            if (currentFilter === 'all') show = true;
            else if (currentFilter === 'reinf' && row.classList.contains('is-reinforcement')) show = true;
            else if (currentFilter === 'diver' && row.classList.contains('is-divergence')) show = true;
            else if (currentFilter === 'return' && row.classList.contains('is-return')) show = true;
            row.classList.toggle('filtered-out', !show);
        });
        drawWave(idx);
    });
});

resetBtn.onclick = () => {
    TURNS = JSON.parse(JSON.stringify(TURNS_ORIGINAL));
    buildRows();
    revealUpTo(0);
    playing = false;
    playBtn.disabled = false;
    pauseBtn.disabled = true;
};

function frame(ts){
  requestAnimationFrame(frame);
  if (playing && ts - last > stepMs && idx < TURNS.length-1){
    revealUpTo(idx+1);
    last = ts;
  }
  for (let i = activeRipples.length - 1; i >= 0; i--) {
      const ripple = activeRipples[i];
      ripple.life -= 0.02;
      ripple.radius += 1;
      if (ripple.life <= 0) {
          activeRipples.splice(i, 1);
      }
  }
  if (activeRipples.length > 0 || playing || hoveredWaveIndex > -1) {
      drawWave(idx);
  }
    const targetReinfPct = parseFloat(document.getElementById('reinforcePct').textContent) / 100 || 0;
    const targetDiverPct = parseFloat(document.getElementById('divergePct').textContent) / 100 || 0;

    reinfPctAnimated += (targetReinfPct - reinfPctAnimated) * 0.1;
    diverPctAnimated += (targetDiverPct - diverPctAnimated) * 0.1;

    drawRadialProgress(reinfCtx, reinfPctAnimated, 'var(--mint)');
    drawRadialProgress(diverCtx, diverPctAnimated, 'var(--coral)');
}

buildRows();
window.addEventListener('load', () => {
    document.body.classList.remove('booting');
    setTimeout(() => {
        revealUpTo(0);
        playing = true;
        playBtn.disabled = true;
        pauseBtn.disabled = false;
        last = performance.now();
        requestAnimationFrame(frame);
    }, 800);
});
</script>
</body>
</html>

