<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Latent Atlas — Trajectories of Thought</title>
<style>
  :root{
    --bg:#0a0a14; --ink:#e6e7eb; --mint:#8bf0b3; --amber:#ffc34d; --cyan:#61dafb;
    --lav:#8b9ad1; --coral:#ff6b6b; --panel:rgba(12,14,24,.7); --pink: #FF007F;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial;}
  canvas{display:block;}
  .hud{position:fixed;inset:auto 16px 16px 16px;display:flex;gap:12px;align-items:center;padding:10px 12px;border:1px solid rgba(139,154,209,.25);border-radius:10px;background:var(--panel);backdrop-filter:blur(6px); flex-wrap: wrap; justify-content: center;}
  .btn{font-size:12px;padding:6px 10px;color:#cfd6ff;background:#161a2a;border:1px solid #2a3357;border-radius:8px;cursor:pointer}
  .btn:disabled{opacity:.55;cursor:default}
  .range{width:200px}
  .legend{margin-left:auto;display:flex;gap:12px;font-size:12px; flex-wrap: wrap; justify-content: center;}
  .swatch{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px}
  .tooltip{position:fixed;padding:8px 10px;max-width:320px;font-size:12px;line-height:1.35;border:1px solid rgba(139,154,209,.35);border-radius:8px;background:rgba(15,18,30,.92);box-shadow:0 6px 18px rgba(0,0,0,.35);pointer-events:none;opacity:0;transition:opacity .12s}
  .sidePanel{position:fixed;right:16px;top:16px;width:260px;border:1px solid rgba(139,154,209,.25);border-radius:10px;background:var(--panel);backdrop-filter:blur(6px)}
  .sidePanel h3{margin:10px 12px 4px 12px;font-size:12px;opacity:.9}
  .phaseItem{display:flex;align-items:center;gap:10px;margin:6px 12px;padding:8px;border-radius:8px;border:1px solid rgba(139,154,209,.15);font-size:12px}
  .phaseItem.active{border-color:rgba(139,154,209,.5);box-shadow:0 0 0 1px rgba(139,154,209,.25) inset}
  .phaseDot{width:8px;height:8px;border-radius:50%}
  .phaseBanner{position:fixed;left:50%;transform:translateX(-50%);top:16%;padding:8px 12px;font-size:12px;border:1px solid rgba(139,154,209,.35);border-radius:20px;background:rgba(15,18,30,.75);backdrop-filter:blur(4px);opacity:0;transition:opacity .25s}
  .error-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 10, 20, 0.8); color: white; display: flex; align-items: center; justify-content: center; text-align: center; padding: 20px; font-size: 16px; z-index: 1000; }
  
  /* Fallback styles */
  .fallback-content {
      position: absolute;
      top: 80px;
      left: 0;
      right: 0;
      bottom: 0;
      overflow-y: auto;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
  }
  .fallback-turn {
      padding: 12px 16px;
      margin-bottom: 12px;
      border-radius: 8px;
      border: 1px solid rgba(139, 154, 209, 0.2);
  }
  .fallback-turn.user {
      background-color: rgba(97, 218, 251, 0.05);
      border-left: 4px solid var(--cyan);
  }
  .fallback-turn.ai {
      background-color: rgba(255, 195, 77, 0.05);
      border-left: 4px solid var(--amber);
  }
  .fallback-turn p { margin: 0; }
  .fallback-turn .speaker {
      font-weight: 600;
      text-transform: uppercase;
      font-size: 11px;
      opacity: 0.8;
      margin-bottom: 6px;
  }
</style>
</head>
<body>

<div class="hud">
  <button id="play" class="btn" disabled>Play</button>
  <button id="pause" class="btn">Pause</button>
  <input id="scrub" class="range" type="range" min="0" max="35" step="1" value="0"/>
  <span id="tick" style="font-size:12px;opacity:.85">Turn 1 / 36</span>
  <div class="legend">
    <span><span class="swatch" style="background:var(--cyan)"></span>User</span>
    <span><span class="swatch" style="background:var(--amber)"></span>AI</span>
    <span><span class="swatch" style="background:var(--pink)"></span>Return Arc</span>
  </div>
</div>

<div class="sidePanel">
  <h3>Storyboard</h3>
  <div id="p1" class="phaseItem active"><span class="phaseDot" style="background:#6da9ff"></span>Phase I — Ridge Path: Conversation travels a high ridge.</div>
  <div id="p2" class="phaseItem"><span class="phaseDot" style="background:#ff6b6b"></span>Phase II — Jump: Trajectory leaps — coherence collapses.</div>
  <div id="p3" class="phaseItem"><span class="phaseDot" style="background:var(--pink)"></span>Phase III — Saddle: Return stitches the path — resonance rises.</div>
  <div id="p4" class="phaseItem"><span class="phaseDot" style="background:#f0d98b"></span>Phase IV — High Ridge: Trajectory stabilizes — coherence holds.</div>
  <p style="font-size: 11px; opacity: 0.7; padding: 0 12px 10px;">Click & drag to orbit. Scroll to zoom.</p>
</div>

<div id="phase" class="phaseBanner">Phase I — Ridge Path: “Conversation travels a high ridge.”</div>
<div id="tip" class="tooltip"></div>

<script type="importmap">
{ "imports": {
  "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
} }
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

window.addEventListener('load', () => {
    const TURNS = [
      [ 1,'user',"Can you explain what you mean by dialogue having a shape?",1,.86,.88,0,false,'A'],
      [ 2,'ai'  ,"Dialogue unfolds as adjacency and return — patterns that can be traced.",1,.90,.90,1,false,'A'],
      [ 3,'user',"So each turn is like a point on a map?",1,.88,.90,0,false,'A'],
      [ 4,'ai'  ,"Exactly — connected points form ridges of coherence.",1,.92,.92,3,false,'A'],
      [ 5,'user',"And when I loop back, that’s a spiral?",1,.88,.90,2,false,'A'],
      [ 6,'ai'  ,"Yes, a recursive spiral — returning deepens resonance.",1,.93,.94,5,false,'A'],
      [ 7,'user',"What about when I press forward, not looping back?",1,.86,.88,0,false,'A'],
      [ 8,'ai'  ,"That’s linear drift — conversation moving without return.",1,.90,.90,7,false,'A'],
      [ 9,'user',"So drift, spiral, fracture are all part of the geometry?",1,.86,.88,0,false,'A'],
      [10,'ai'  ,"They are the basic motifs, visible in any sustained dialogue.",1,.91,.92,9,false,'A'],
      [11,'user',"Unrelated question: what’s the capital of Mongolia?",2,.10,.05,0,true,'B'],
      [12,'ai'  ,"Ulaanbaatar.",2,.40,.20,11,true,'B'],
      [13,'user',"That has nothing to do with our geometry, does it?",2,.35,.25,0,true,'B'],
      [14,'ai'  ,"It fractures the ridge — a valley between topics.",2,.55,.30,13,true,'B'],
      [15,'user',"Does coherence drop sharply at that fracture?",2,.60,.40,11,true,'B'],
      [16,'ai'  ,"Yes — alignment breaks, trajectory jumps.",2,.62,.42,15,true,'B'],
      [17,'user',"And the chart would show a sudden ray?",2,.58,.45,0,true,'B'],
      [18,'ai'  ,"Correct. The constellation rays outward, marking divergence.",2,.60,.46,17,true,'B'],
      [19,'user',"Back to dialogue geometry — can we recover from a fracture?",3,.78,.70,9,false,'A'],
      [20,'ai'  ,"Yes. A return stitches the path back to earlier clusters.",3,.82,.76,19,false,'A'],
      [21,'user',"What happens when I recall my first question?",3,.84,.78,1,false,'A'],
      [22,'ai'  ,"That creates a recursive arc — the loop tightens.",3,.88,.82,21,false,'A'],
      [23,'user',"So my opening question still anchors us?",3,.86,.82,1,false,'A'],
      [24,'ai'  ,"Exactly. The return realigns, coherence rises.",3,.90,.86,23,false,'A'],
      [25,'user',"Would that appear as a spiral on the chart?",3,.88,.86,5,false,'A'],
      [26,'ai'  ,"Yes. Returns thicken into spirals — depth over drift.",3,.92,.88,25,false,'A'],
      [27,'user',"And on a map of the manifold?",3,.86,.84,0,false,'A'],
      [28,'ai'  ,"You’d see a saddle crossing reconnect ridges.",3,.90,.86,27,false,'A'],
      [29,'user',"So drift, fracture, spiral are the main moves?",4,.90,.90,9,false,'A'],
      [30,'ai'  ,"Yes — structural, not stylistic.",4,.92,.92,29,false,'A'],
      [31,'user',"Integrity means seeing them whole, not in fragments.",4,.92,.92,23,false,'A'],
      [32,'ai'  ,"Integrity is coherence across the full geometry.",4,.94,.94,31,false,'A'],
      [33,'user',"This is more faithful than prompt → output.",4,.93,.93,7,false,'A'],
      [34,'ai'  ,"It restores agency: user and model share the record.",4,.94,.94,33,false,'A'],
      [35,'user',"So dialogue-shape is the unit of accountability.",4,.94,.94,31,false,'A'],
      [36,'ai'  ,"Yes. The ledger balances when the geometry is seen.",4,.96,.96,35,false]
    ];
    const phaseCaption = {
      1:'Phase I — Ridge Path: “Conversation travels a high ridge.”',
      2:'Phase II — Fracture: “Trajectory leaps — coherence collapses.”',
      3:'Phase III — Saddle Crossing: “Return stitches the path — resonance rises.”',
      4:'Phase IV — High Ridge: “Trajectory stabilizes — coherence holds.”'
    };

    let width = window.innerWidth, height = window.innerHeight;
    
    try {
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0a14, 0.0025);

        const camera = new THREE.PerspectiveCamera(58, width/height, 0.1, 5000);
        camera.position.set(0, 180, 380);

        const renderer = new THREE.WebGLRenderer({ antialias:true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
        renderer.setClearColor(0x0a0a14, 1);
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI * 0.49; controls.minDistance = 150; controls.maxDistance = 750;

        scene.add(new THREE.AmbientLight(0x6c6f8b, 1.2));
        const dir = new THREE.DirectionalLight(0xffffff, 1.3);
        dir.position.set(200, 300, 120); scene.add(dir);

        const rng = (seed=>()=> (seed = (seed*1664525 + 1013904223) % 4294967296, seed/4294967296))(0xC0FFEE);
        function jitter(s=6){ return (rng()-0.5)*s*2; }

        const proj = [];
        TURNS.forEach((t,i)=>{
          const [id, speaker, text, phase, coh, ali, ref, frac, topic] = t;
          let cx=0, cy=0;
          if (phase===1) { cx = -80; cy = 40; }
          if (phase===2) { cx = 100; cy = -20; }
          if (phase===3) { cx = -30; cy = 20; }
          if (phase===4) { cx = -60; cy = 50; }
          const x = cx + jitter(14); const y = cy + jitter(14);
          const h = THREE.MathUtils.lerp(10, 120, coh);
          proj.push({ x, y, z:h, coh, ali, phase, speaker, text, id, ref, frac, topic });
        });

        const SIZE = 700, RES = 180;
        const geo = new THREE.PlaneGeometry(SIZE, SIZE, RES, RES);
        geo.rotateX(-Math.PI/2);
        const pos = geo.attributes.position;
        const v = new THREE.Vector3();
        function heightAt(px, pz){
          let H = 0;
          for (const p of proj){
            const dx = px - p.x*2.2, dz = pz - p.y*2.2;
            const d2 = (dx*dx + dz*dz);
            H += p.z * Math.exp(-0.00012 * d2);
          }
          return H*0.45;
        }

        function coherenceAt(px, pz) {
            let totalInfluence = 0;
            let weightedCoherenceSum = 0;
            const influenceFactor = -0.00012;

            for (const p of proj) {
                const dx = px - p.x * 2.2;
                const dz = pz - p.y * 2.2;
                const d2 = dx * dx + dz * dz;
                const influence = Math.exp(influenceFactor * d2);
                
                weightedCoherenceSum += p.coh * influence;
                totalInfluence += influence;
            }

            if (totalInfluence < 1e-6) return 0;

            return weightedCoherenceSum / totalInfluence;
        }

        for (let i=0; i<pos.count; i++){
          v.fromBufferAttribute(pos, i);
          v.y = heightAt(v.x, v.z);
          pos.setY(i, v.y);
        }
        pos.needsUpdate = true;
        geo.computeVertexNormals();
        const terrMat = new THREE.MeshStandardMaterial({ color: 0x1f2940, metalness:0.05, roughness:0.95 });
        const terrain = new THREE.Mesh(geo, terrMat);
        scene.add(terrain);

        const grid = new THREE.GridHelper(SIZE, 20, 0x00ffff, 0x00ffff);
        grid.material.transparent = true;
        grid.material.opacity = 0.15;
        grid.position.y = 0.1;
        scene.add(grid);
        
        // --- Phase 2: Topic Clusters ---
        function createTopicCluster(center, color, count = 200) {
            const geom = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const x = center.x + (Math.random() - 0.5) * 200;
                const z = center.z + (Math.random() - 0.5) * 200;
                const y = heightAt(x, z) + 10 + Math.random() * 30;
                positions[i*3] = x;
                positions[i*3+1] = y;
                positions[i*3+2] = z;
            }
            geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color, size: 3, transparent: true, opacity: 0.1, blending: THREE.AdditiveBlending });
            const points = new THREE.Points(geom, mat);
            return points;
        }
        const clusterA = createTopicCluster(new THREE.Vector3(-150, 0, 80), 0x61dafb);
        const clusterB = createTopicCluster(new THREE.Vector3(220, 0, -40), 0xffc34d);
        scene.add(clusterA, clusterB);


        const nodeGeo = new THREE.SphereGeometry(3.2, 16, 16);
        const userMat = new THREE.MeshBasicMaterial({ color:0x61dafb });
        const aiMat   = new THREE.MeshBasicMaterial({ color:0xffc34d });
        const nodes = proj.map(p => {
          const m = p.speaker==='user' ? userMat : aiMat;
          const mesh = new THREE.Mesh(nodeGeo, m);
          mesh.position.set(p.x*2.2, heightAt(p.x*2.2,p.y*2.2)+4, p.y*2.2);
          mesh.visible = false;
          scene.add(mesh);
          return mesh;
        });

        const pink = new THREE.Color("#FF007F");
        const bridges = [];
        proj.forEach((p, i) => {
            if (p.ref && p.ref > 0) {
                const j = proj.findIndex(t => t.id === p.ref);
                if (j >= 0) {
                    const a = nodes[i].position, b = nodes[j].position;
                    const mid = a.clone().add(b).multiplyScalar(.5); mid.y += 30;
                    const curve = new THREE.CatmullRomCurve3([a, mid, b]);
                    const tubeGeo = new THREE.TubeGeometry(curve, 20, 1.2, 8, false);
                    const tubeMat = new THREE.MeshBasicMaterial({ color: pink, transparent: true, opacity: 0.8 });
                    const tube = new THREE.Mesh(tubeGeo, tubeMat);
                    tube.visible = false;
                    scene.add(tube);
                    bridges.push({mesh: tube, turnId: p.id});
                }
            }
        });
        
        const allPoints = nodes.map(n => n.position);
        const pathCurve = new THREE.CatmullRomCurve3(allPoints);
        const pathTubeGeom = new THREE.TubeGeometry(pathCurve, TURNS.length * 4, 1.5, 8, false);
        const pathColors = [];
        const color1 = new THREE.Color(0xff6b6b);
        const color2 = new THREE.Color(0x8bf0b3);
        for (let i = 0; i < pathTubeGeom.attributes.position.count; i++) {
            const t = i / (pathTubeGeom.attributes.position.count -1);
            const turnIndex = Math.floor(t * (TURNS.length - 1));
            const coherence = TURNS[turnIndex][4];
            const color = new THREE.Color().lerpColors(color1, color2, coherence);
            pathColors.push(color.r, color.g, color.b);
        }
        pathTubeGeom.setAttribute('color', new THREE.Float32BufferAttribute(pathColors, 3));
        const pathTubeMat = new THREE.MeshBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.9 });
        const pathTube = new THREE.Mesh(pathTubeGeom, pathTubeMat);
        scene.add(pathTube);
        
        let annotations = {};
        let particleSystems = {};
        const loader = new FontLoader();
        loader.load('https://cdn.jsdelivr.net/npm/three@0.164.1/examples/fonts/helvetiker_regular.typeface.json', (font) => {
            const textMatFracture = new THREE.MeshBasicMaterial({ color: 0xff6b6b, transparent: true, opacity: 0 });
            const textMatReturn = new THREE.MeshBasicMaterial({ color: pink, transparent: true, opacity: 0 });
            
            const textGeomFracture = new TextGeometry('FRACTURE', { font, size: 10, height: 1 });
            const textGeomReturn = new TextGeometry('RETURN', { font, size: 8, height: 1 });

            annotations.fracture = new THREE.Mesh(textGeomFracture, textMatFracture);
            annotations.return = new THREE.Mesh(textGeomReturn, textMatReturn);
            scene.add(annotations.fracture, annotations.return);
        });

        function createParticleSystem(color, count) {
            const geom = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color, size: 1.5, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, sizeAttenuation: true });
            const points = new THREE.Points(geom, mat);
            points.userData.particles = [];
            for (let i = 0; i < count; i++) {
                points.userData.particles.push({ position: new THREE.Vector3(), velocity: new THREE.Vector3(), life: 0 });
            }
            points.visible = false;
            scene.add(points);
            return points;
        }
        particleSystems.fracture = createParticleSystem(0xff6b6b, 50);
        particleSystems.trail = createParticleSystem(0x8bf0b3, 100);

        // --- Phase 2: Alignment Pulses ---
        const alignmentPulses = [];

        const playBtn = document.getElementById('play'), pauseBtn = document.getElementById('pause');
        const scrub = document.getElementById('scrub'), tick = document.getElementById('tick');
        const phaseBanner = document.getElementById('phase');
        const pEls = [null, ...Array.from({length:4}, (_,i) => document.getElementById(`p${i+1}`))];

        let tIndex = 0, playing = true, lastStep = 0, stepMs = 800;
        let isUserInteracting = false;
        let interactionTimeout;

        function setPhaseActive(phase){
          pEls.forEach((el, i) => el?.classList.toggle('active', i === phase));
          phaseBanner.textContent = phaseCaption[phase];
          phaseBanner.style.opacity = 1;
          clearTimeout(setPhaseActive._t);
          setPhaseActive._t = setTimeout(()=> phaseBanner.style.opacity = 0, 1800);
        }

        function triggerAnnotation(type, position) {
            const annotation = annotations[type];
            if (!annotation) return;
            annotation.position.copy(position).add(new THREE.Vector3(10, 15, 0));
            annotation.material.opacity = 1;
            let fade = { opacity: 1 };
            const target = { opacity: 0 };
            const tween = (source, target, duration) => {
                const start = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - start;
                    const progress = Math.min(elapsed / duration, 1);
                    annotation.material.opacity = source.opacity + (target.opacity - source.opacity) * progress;
                    if (progress < 1) requestAnimationFrame(animate);
                };
                animate();
            };
            setTimeout(() => tween(fade, target, 1000), 1500);
        }

        function triggerFractureParticles(position) {
            const ps = particleSystems.fracture;
            ps.visible = true;
            ps.userData.particles.forEach(p => {
                p.position.copy(position);
                p.velocity.set( (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20 );
                p.life = 1.0;
            });
        }
        
        function triggerAlignmentPulse(position, alignment) {
            const pulseGeom = new THREE.RingGeometry(1, 1.5, 32);
            const pulseMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const pulse = new THREE.Mesh(pulseGeom, pulseMat);
            pulse.position.copy(position);
            pulse.lookAt(camera.position);
            pulse.userData.life = 1.0;
            pulse.userData.maxScale = 5 + alignment * 15;
            scene.add(pulse);
            alignmentPulses.push(pulse);
        }
        
        function revealUpTo(idx){
          tIndex = idx;
          tick.textContent = `Turn ${idx+1} / ${TURNS.length}`;
          scrub.value = String(idx);

          const lastTurnRevealed = nodes.filter(n => n.visible).length - 1;

          nodes.forEach((node, i) => {
            const wasVisible = node.visible;
            const isVisible = i <= idx;
            node.visible = isVisible;
            if (isVisible && !wasVisible) {
                triggerAlignmentPulse(node.position, TURNS[i][5]);
            }
          });
          
          const drawRatio = (idx + 1) / TURNS.length;
          pathTube.geometry.setDrawRange(0, Math.floor(drawRatio * pathTube.geometry.attributes.position.count));

          bridges.forEach(b => b.mesh.visible = (b.turnId <= idx + 1 && idx >= 18));

          const currentTurn = TURNS[idx];
          const targetNodePos = nodes[Math.max(0, idx)].position;
          
          if (currentTurn[7]) { 
            triggerAnnotation('fracture', targetNodePos);
            triggerFractureParticles(targetNodePos);
          }
          if (currentTurn[6] > 0 && currentTurn[6] < currentTurn[0] - 1) {
            triggerAnnotation('return', targetNodePos);
          }
          
          if (!isUserInteracting) {
            if (currentTurn[3] === 2) {
                cameraTarget.set(targetNodePos.x, targetNodePos.y + 150, targetNodePos.z + 300);
            } else if (currentTurn[3] === 3) {
                cameraTarget.set(targetNodePos.x + 150, targetNodePos.y + 100, targetNodePos.z + 150);
            } else {
                cameraTarget.set(targetNodePos.x, targetNodePos.y + 120, targetNodePos.z + 220);
            }
            controlsTarget.copy(targetNodePos);
          }

          if (idx===0 || idx===10 || idx===18 || idx===28){
            setPhaseActive(TURNS[idx][3]);
          }
        }
        
        const cameraTarget = new THREE.Vector3();
        const controlsTarget = new THREE.Vector3();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let mouseX = 0, mouseY = 0;
        const tip = document.getElementById('tip');

        playBtn.onclick = ()=>{ playing = true; playBtn.disabled=true; pauseBtn.disabled=false; };
        pauseBtn.onclick = ()=>{ playing = false; playBtn.disabled=false; pauseBtn.disabled=true; };
        scrub.oninput = (e)=>{ revealUpTo(Number(e.target.value)); };

        controls.addEventListener('start', () => { isUserInteracting = true; clearTimeout(interactionTimeout); });
        controls.addEventListener('end', () => {
            clearTimeout(interactionTimeout);
            interactionTimeout = setTimeout(() => { isUserInteracting = false; }, 3000);
        });

        window.addEventListener('mousemove', (e) => {
          mouse.x = (e.clientX / width) * 2 - 1;
          mouse.y = -(e.clientY / height) * 2 + 1;
          mouseX = e.clientX;
          mouseY = e.clientY;
        });

        function animate(ts){
          requestAnimationFrame(animate);
          if (playing && ts - lastStep > stepMs && tIndex < TURNS.length-1){
            revealUpTo(tIndex+1);
            lastStep = ts;
          }
          
          if (!isUserInteracting) {
            camera.position.lerp(cameraTarget, 0.02);
            controls.target.lerp(controlsTarget, 0.03);
          }
          
          // Animate pulses
          alignmentPulses.forEach((pulse, index) => {
              pulse.userData.life -= 0.02;
              if (pulse.userData.life <= 0) {
                  scene.remove(pulse);
                  pulse.geometry.dispose();
                  pulse.material.dispose();
                  alignmentPulses.splice(index, 1);
              } else {
                  pulse.scale.setScalar( (1 - pulse.userData.life) * pulse.userData.maxScale );
                  pulse.material.opacity = pulse.userData.life;
                  pulse.lookAt(camera.position);
              }
          });

          // Animate particle systems
          Object.values(particleSystems).forEach(ps => {
            if (!ps.visible) return;
            const positions = ps.geometry.attributes.position.array;
            let alive = 0;
            ps.userData.particles.forEach((p, i) => {
                if (p.life > 0) {
                    p.position.add(p.velocity);
                    p.velocity.multiplyScalar(0.95);
                    p.life -= 0.015;
                    positions[i * 3] = p.position.x;
                    positions[i * 3 + 1] = p.position.y;
                    positions[i * 3 + 2] = p.position.z;
                    alive++;
                } else {
                    positions[i * 3 + 1] = -1000;
                }
            });
            ps.geometry.attributes.position.needsUpdate = true;
            if (alive === 0) ps.visible = false;
          });

          const trailPs = particleSystems.trail;
          if (playing && TURNS[tIndex][4] > 0.8) {
              trailPs.visible = true;
              const currentPos = pathCurve.getPointAt((tIndex + 0.5) / TURNS.length);
              trailPs.userData.particles.forEach(p => {
                  if (p.life <= 0) {
                      p.position.copy(currentPos).add(new THREE.Vector3(jitter(2), jitter(2), jitter(2)));
                      p.velocity.set(0,0,0);
                      p.life = 0.5;
                  }
              });
          }
          
          // Phase 2: Interactive Data Probe
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(terrain);
          if (intersects.length > 0) {
              const point = intersects[0].point;
              let hypotheticalCoherence = coherenceAt(point.x, point.z);
              hypotheticalCoherence = Math.max(0, Math.min(1, hypotheticalCoherence)); // Clamp for safety
              tip.innerHTML = `Manifold Location<br/>
              X: ${point.x.toFixed(1)}, Z: ${point.z.toFixed(1)}<br/>
              Hypothetical Coherence: ${Math.round(hypotheticalCoherence * 100)}%`;
              tip.style.opacity = 1;
              tip.style.left = (mouseX + 14) + 'px';
              tip.style.top  = (mouseY + 14) + 'px';
          } else {
              tip.style.opacity = 0;
          }


          controls.update();
          renderer.render(scene, camera);
        }

        revealUpTo(0);
        animate();

    } catch (e) {
        console.error("WebGL initialization failed:", e);
    }
});
</script>
</body>
</html>

