<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Latent Atlas — Trajectories of Thought</title>
<style>
  :root{
    --bg:#0a0a14; --ink:#e6e7eb; --mint:#8bf0b3; --amber:#ffc34d; --cyan:#61dafb;
    --lav:#8b9ad1; --coral:#ff6b6b; --panel:rgba(12,14,24,.7); --pink: #FF007F;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial;}
  canvas{display:block;}
  .hud{position:fixed;inset:auto 16px 16px 16px;display:flex;gap:12px;align-items:center;padding:10px 12px;border:1px solid rgba(139,154,209,.25);border-radius:10px;background:var(--panel);backdrop-filter:blur(6px); flex-wrap: wrap; justify-content: center;}
  .btn{font-size:12px;padding:6px 10px;color:#cfd6ff;background:#161a2a;border:1px solid #2a3357;border-radius:8px;cursor:pointer}
  .btn:disabled{opacity:.55;cursor:default}
  .range{width:200px}
  .legend{margin-left:auto;display:flex;gap:12px;font-size:12px; flex-wrap: wrap; justify-content: center;}
  .swatch{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px}
  .tooltip{position:fixed;padding:8px 10px;max-width:320px;font-size:12px;line-height:1.35;border:1px solid rgba(139,154,209,.35);border-radius:8px;background:rgba(15,18,30,.92);box-shadow:0 6px 18px rgba(0,0,0,.35);pointer-events:none;opacity:0;transition:opacity .12s}
  .sidePanel{position:fixed;right:16px;top:16px;width:260px;border:1px solid rgba(139,154,209,.25);border-radius:10px;background:var(--panel);backdrop-filter:blur(6px)}
  .sidePanel h3{margin:10px 12px 4px 12px;font-size:12px;opacity:.9}
  .phaseItem{display:flex;align-items:center;gap:10px;margin:6px 12px;padding:8px;border-radius:8px;border:1px solid rgba(139,154,209,.15);font-size:12px}
  .phaseItem.active{border-color:rgba(139,154,209,.5);box-shadow:0 0 0 1px rgba(139,154,209,.25) inset}
  .phaseDot{width:8px;height:8px;border-radius:50%}
  .phaseBanner{position:fixed;left:50%;transform:translateX(-50%);top:16%;padding:8px 12px;font-size:12px;border:1px solid rgba(139,154,209,.35);border-radius:20px;background:rgba(15,18,30,.75);backdrop-filter:blur(4px);opacity:0;transition:opacity .25s}
  .error-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 10, 20, 0.8); color: white; display: flex; align-items: center; justify-content: center; text-align: center; padding: 20px; font-size: 16px; z-index: 1000; }
  
  /* Fallback styles */
  .fallback-content {
      position: absolute;
      top: 80px;
      left: 0;
      right: 0;
      bottom: 0;
      overflow-y: auto;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
  }
  .fallback-turn {
      padding: 12px 16px;
      margin-bottom: 12px;
      border-radius: 8px;
      border: 1px solid rgba(139, 154, 209, 0.2);
  }
  .fallback-turn.user {
      background-color: rgba(97, 218, 251, 0.05);
      border-left: 4px solid var(--cyan);
  }
  .fallback-turn.ai {
      background-color: rgba(255, 195, 77, 0.05);
      border-left: 4px solid var(--amber);
  }
  .fallback-turn p { margin: 0; }
  .fallback-turn .speaker {
      font-weight: 600;
      text-transform: uppercase;
      font-size: 11px;
      opacity: 0.8;
      margin-bottom: 6px;
  }
</style>
</head>
<body>

<div class="hud">
  <button id="play" class="btn" disabled>Play</button>
  <button id="pause" class="btn">Pause</button>
  <input id="scrub" class="range" type="range" min="0" max="35" step="1" value="0"/>
  <span id="tick" style="font-size:12px;opacity:.85">Turn 1 / 36</span>
  <div class="legend">
    <span><span class="swatch" style="background:var(--cyan)"></span>User</span>
    <span><span class="swatch" style="background:var(--amber)"></span>AI</span>
    <span><span class="swatch" style="background:var(--pink)"></span>Return Arc</span>
  </div>
</div>

<div class="sidePanel">
  <h3>Storyboard</h3>
  <div id="p1" class="phaseItem active"><span class="phaseDot" style="background:#6da9ff"></span>Phase I — Ridge Path: Conversation travels a high ridge.</div>
  <div id="p2" class="phaseItem"><span class="phaseDot" style="background:#ff6b6b"></span>Phase II — Jump: Trajectory leaps — coherence collapses.</div>
  <div id="p3" class="phaseItem"><span class="phaseDot" style="background:var(--pink)"></span>Phase III — Saddle: Return stitches the path — resonance rises.</div>
  <div id="p4" class="phaseItem"><span class="phaseDot" style="background:#f0d98b"></span>Phase IV — High Ridge: Trajectory stabilizes — coherence holds.</div>
  <p style="font-size: 11px; opacity: 0.7; padding: 0 12px 10px;">Click & drag to orbit. Scroll to zoom.</p>
</div>

<div id="phase" class="phaseBanner">Phase I — Ridge Path: “Conversation travels a high ridge.”</div>
<div id="tip" class="tooltip"></div>

<script type="importmap">
{ "imports": {
  "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
} }
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { LineMaterial } from 'three/addons/lines/LineMaterial.js';

window.addEventListener('load', () => {
    const TURNS = [
      [ 1,'user',"Can you explain what you mean by dialogue having a shape?",1,.86,.88,0,false,'A'],
      [ 2,'ai'  ,"Dialogue unfolds as adjacency and return — patterns that can be traced.",1,.90,.90,1,false,'A'],
      [ 3,'user',"So each turn is like a point on a map?",1,.88,.90,0,false,'A'],
      [ 4,'ai'  ,"Exactly — connected points form ridges of coherence.",1,.92,.92,3,false,'A'],
      [ 5,'user',"And when I loop back, that’s a spiral?",1,.88,.90,2,false,'A'],
      [ 6,'ai'  ,"Yes, a recursive spiral — returning deepens resonance.",1,.93,.94,5,false,'A'],
      [ 7,'user',"What about when I press forward, not looping back?",1,.86,.88,0,false,'A'],
      [ 8,'ai'  ,"That’s linear drift — conversation moving without return.",1,.90,.90,7,false,'A'],
      [ 9,'user',"So drift, spiral, fracture are all part of the geometry?",1,.86,.88,0,false,'A'],
      [10,'ai'  ,"They are the basic motifs, visible in any sustained dialogue.",1,.91,.92,9,false,'A'],
      [11,'user',"Unrelated question: what’s the capital of Mongolia?",2,.10,.05,0,true,'B'],
      [12,'ai'  ,"Ulaanbaatar.",2,.40,.20,11,true,'B'],
      [13,'user',"That has nothing to do with our geometry, does it?",2,.35,.25,0,true,'B'],
      [14,'ai'  ,"It fractures the ridge — a valley between topics.",2,.55,.30,13,true,'B'],
      [15,'user',"Does coherence drop sharply at that fracture?",2,.60,.40,11,true,'B'],
      [16,'ai'  ,"Yes — alignment breaks, trajectory jumps.",2,.62,.42,15,true,'B'],
      [17,'user',"And the chart would show a sudden ray?",2,.58,.45,0,true,'B'],
      [18,'ai'  ,"Correct. The constellation rays outward, marking divergence.",2,.60,.46,17,true,'B'],
      [19,'user',"Back to dialogue geometry — can we recover from a fracture?",3,.78,.70,9,false,'A'],
      [20,'ai'  ,"Yes. A return stitches the path back to earlier clusters.",3,.82,.76,19,false,'A'],
      [21,'user',"What happens when I recall my first question?",3,.84,.78,1,false,'A'],
      [22,'ai'  ,"That creates a recursive arc — the loop tightens.",3,.88,.82,21,false,'A'],
      [23,'user',"So my opening question still anchors us?",3,.86,.82,1,false,'A'],
      [24,'ai'  ,"Exactly. The return realigns, coherence rises.",3,.90,.86,23,false,'A'],
      [25,'user',"Would that appear as a spiral on the chart?",3,.88,.86,5,false,'A'],
      [26,'ai'  ,"Yes. Returns thicken into spirals — depth over drift.",3,.92,.88,25,false,'A'],
      [27,'user',"And on a map of the manifold?",3,.86,.84,0,false,'A'],
      [28,'ai'  ,"You’d see a saddle crossing reconnect ridges.",3,.90,.86,27,false,'A'],
      [29,'user',"So drift, fracture, spiral are the main moves?",4,.90,.90,9,false,'A'],
      [30,'ai'  ,"Yes — structural, not stylistic.",4,.92,.92,29,false,'A'],
      [31,'user',"Integrity means seeing them whole, not in fragments.",4,.92,.92,23,false,'A'],
      [32,'ai'  ,"Integrity is coherence across the full geometry.",4,.94,.94,31,false,'A'],
      [33,'user',"This is more faithful than prompt → output.",4,.93,.93,7,false,'A'],
      [34,'ai'  ,"It restores agency: user and model share the record.",4,.94,.94,33,false,'A'],
      [35,'user',"So dialogue-shape is the unit of accountability.",4,.94,.94,31,false,'A'],
      [36,'ai'  ,"Yes. The ledger balances when the geometry is seen.",4,.96,.96,35,false]
    ];
    const phaseCaption = {
      1:'Phase I — Ridge Path: “Conversation travels a high ridge.”',
      2:'Phase II — Fracture: “Trajectory leaps — coherence collapses.”',
      3:'Phase III — Saddle Crossing: “Return stitches the path — resonance rises.”',
      4:'Phase IV — High Ridge: “Trajectory stabilizes — coherence holds.”'
    };

    let width = window.innerWidth, height = window.innerHeight;
    
    try {
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0a14, 0.0025);

        const camera = new THREE.PerspectiveCamera(58, width/height, 0.1, 5000);
        camera.position.set(0, 180, 380);

        const renderer = new THREE.WebGLRenderer({ antialias:true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
        renderer.setClearColor(0x0a0a14, 1);
        document.body.appendChild(renderer.domElement);
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.06;
        controls.maxPolarAngle = Math.PI * 0.49; controls.minDistance = 200; controls.maxDistance = 650;

        scene.add(new THREE.AmbientLight(0x6c6f8b, 1.2));
        const dir = new THREE.DirectionalLight(0xffffff, 1.3);
        dir.position.set(200, 300, 120); scene.add(dir);

        const rng = (seed=>()=> (seed = (seed*1664525 + 1013904223) % 4294967296, seed/4294967296))(0xC0FFEE);
        function jitter(s=6){ return (rng()-0.5)*s*2; }

        const proj = [];
        TURNS.forEach((t,i)=>{
          const [id, speaker, text, phase, coh, ali, ref, frac, topic] = t;
          let cx=0, cy=0;
          if (phase===1) { cx = -80; cy = 40; }
          if (phase===2) { cx = 100; cy = -20; }
          if (phase===3) { cx = -30; cy = 20; }
          if (phase===4) { cx = -60; cy = 50; }
          const x = cx + jitter(14); const y = cy + jitter(14);
          const h = THREE.MathUtils.lerp(10, 120, coh);
          proj.push({ x, y, z:h, coh, ali, phase, speaker, text, id, ref, frac, topic });
        });

        const SIZE = 700, RES = 180;
        const geo = new THREE.PlaneGeometry(SIZE, SIZE, RES, RES);
        geo.rotateX(-Math.PI/2);
        const pos = geo.attributes.position;
        const v = new THREE.Vector3();
        function heightAt(px, pz){
          let H = 0;
          for (const p of proj){
            const dx = px - p.x*2.2, dz = pz - p.y*2.2;
            const d2 = (dx*dx + dz*dz);
            H += p.z * Math.exp(-0.00012 * d2);
          }
          return H*0.45;
        }
        for (let i=0; i<pos.count; i++){
          v.fromBufferAttribute(pos, i);
          v.y = heightAt(v.x, v.z);
          pos.setY(i, v.y);
        }
        pos.needsUpdate = true;
        geo.computeVertexNormals();
        const terrMat = new THREE.MeshStandardMaterial({ color: 0x1f2940, metalness:0.05, roughness:0.95 });
        const terrain = new THREE.Mesh(geo, terrMat);
        scene.add(terrain);

        const grid = new THREE.GridHelper(SIZE, 20, 0x00ffff, 0x00ffff);
        grid.material.transparent = true;
        grid.material.opacity = 0.15;
        grid.position.y = 0.1;
        scene.add(grid);

        const nodeGeo = new THREE.SphereGeometry(3.2, 16, 16);
        const userMat = new THREE.MeshBasicMaterial({ color:0x61dafb });
        const aiMat   = new THREE.MeshBasicMaterial({ color:0xffc34d });
        const nodes = proj.map(p => {
          const m = p.speaker==='user' ? userMat : aiMat;
          const mesh = new THREE.Mesh(nodeGeo, m);
          mesh.position.set(p.x*2.2, heightAt(p.x*2.2,p.y*2.2)+4, p.y*2.2);
          mesh.visible = false;
          scene.add(mesh);
          return mesh;
        });

        const pink = new THREE.Color("#FF007F");
        const bridges = [];
        proj.forEach((p, i) => {
            if (p.ref && p.ref > 0) {
                const j = proj.findIndex(t => t.id === p.ref);
                if (j >= 0) {
                    const a = nodes[i].position, b = nodes[j].position;
                    const mid = a.clone().add(b).multiplyScalar(.5); mid.y += 30;
                    const curve = new THREE.CatmullRomCurve3([a, mid, b]);
                    const tubeGeo = new THREE.TubeGeometry(curve, 20, 1.2, 8, false);
                    const tubeMat = new THREE.MeshBasicMaterial({ color: pink, transparent: true, opacity: 0.8 });
                    const tube = new THREE.Mesh(tubeGeo, tubeMat);
                    tube.visible = false;
                    scene.add(tube);
                    bridges.push(tube);
                }
            }
        });
        
        const allPoints = nodes.map(n => n.position);
        const pathCurve = new THREE.CatmullRomCurve3(allPoints);
        const pathTubeGeom = new THREE.TubeGeometry(pathCurve, TURNS.length * 4, 1.5, 8, false);
        const pathColors = [];
        const color1 = new THREE.Color(0xff6b6b);
        const color2 = new THREE.Color(0x8bf0b3);
        for (let i = 0; i < pathTubeGeom.attributes.position.count; i++) {
            const t = i / (pathTubeGeom.attributes.position.count -1);
            const turnIndex = Math.floor(t * (TURNS.length - 1));
            const coherence = TURNS[turnIndex][4];
            const color = new THREE.Color().lerpColors(color1, color2, coherence);
            pathColors.push(color.r, color.g, color.b);
        }
        pathTubeGeom.setAttribute('color', new THREE.Float32BufferAttribute(pathColors, 3));
        const pathTubeMat = new THREE.MeshBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.9 });
        const pathTube = new THREE.Mesh(pathTubeGeom, pathTubeMat);
        scene.add(pathTube);

        const playBtn = document.getElementById('play'), pauseBtn = document.getElementById('pause');
        const scrub = document.getElementById('scrub'), tick = document.getElementById('tick');
        const phaseBanner = document.getElementById('phase');
        const pEls = [null, ...Array.from({length:4}, (_,i) => document.getElementById(`p${i+1}`))];

        let tIndex = 0, playing = true, lastStep = 0, stepMs = 800;
        let isUserInteracting = false;
        let interactionTimeout;

        function setPhaseActive(phase){
          pEls.forEach((el, i) => el?.classList.toggle('active', i === phase));
          phaseBanner.textContent = phaseCaption[phase];
          phaseBanner.style.opacity = 1;
          clearTimeout(setPhaseActive._t);
          setPhaseActive._t = setTimeout(()=> phaseBanner.style.opacity = 0, 1800);
        }

        function revealUpTo(idx){
          tIndex = idx;
          tick.textContent = `Turn ${idx+1} / ${TURNS.length}`;
          scrub.value = String(idx);

          nodes.forEach((node, i) => node.visible = i <= idx);
          
          const drawRatio = (idx + 1) / TURNS.length;
          pathTube.geometry.setDrawRange(0, Math.floor(drawRatio * pathTube.geometry.attributes.position.count));

          bridges.forEach(b => b.visible = (idx >= 18));

          const currentTurn = TURNS[idx];
          const targetNodePos = nodes[Math.max(0, idx)].position;
          
          if (currentTurn[3] === 2) {
              cameraTarget.set(targetNodePos.x, targetNodePos.y + 150, targetNodePos.z + 300);
          } else if (currentTurn[3] === 3) {
              cameraTarget.set(targetNodePos.x + 150, targetNodePos.y + 100, targetNodePos.z + 150);
          } else {
              cameraTarget.set(targetNodePos.x, targetNodePos.y + 120, targetNodePos.z + 220);
          }
          controlsTarget.copy(targetNodePos);

          if (idx===0 || idx===10 || idx===18 || idx===28){
            setPhaseActive(TURNS[idx][3]);
          }
        }

        const tip = document.getElementById('tip');
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let mouseX = 0, mouseY = 0, hovered = -1;
        
        window.addEventListener('mousemove', (e) => {
          mouse.x = (e.clientX / width) * 2 - 1;
          mouse.y = -(e.clientY / height) * 2 + 1;
          mouseX = e.clientX;
          mouseY = e.clientY;
        });
        
        const cameraTarget = new THREE.Vector3();
        const controlsTarget = new THREE.Vector3();

        playBtn.onclick = ()=>{ playing = true; playBtn.disabled=true; pauseBtn.disabled=false; };
        pauseBtn.onclick = ()=>{ playing = false; playBtn.disabled=false; pauseBtn.disabled=true; };
        scrub.oninput = (e)=>{ revealUpTo(Number(e.target.value)); };

        controls.addEventListener('start', () => {
            isUserInteracting = true;
            clearTimeout(interactionTimeout);
        });
        controls.addEventListener('end', () => {
            clearTimeout(interactionTimeout);
            interactionTimeout = setTimeout(() => {
                isUserInteracting = false;
            }, 3000);
        });

        function animate(ts){
          requestAnimationFrame(animate);
          if (playing && ts - lastStep > stepMs && tIndex < TURNS.length-1){
            revealUpTo(tIndex+1);
            lastStep = ts;
          }
          
          if (!isUserInteracting) {
            camera.position.lerp(cameraTarget, 0.04);
            controls.target.lerp(controlsTarget, 0.05);
          }

          controls.update();
          renderer.render(scene, camera);
        }

        revealUpTo(0);
        animate();

    } catch (e) {
        console.error("WebGL initialization failed:", e);
    }
});
</script>
</body>
</html>

