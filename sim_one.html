<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Constellation Charts — Dialogue as Sky</title>
<style>
  :root {
    --bg:#0a0a14; --ink:#e6e7eb; --cyan:#61dafb; --amber:#ffc34d;
    --lav:#8b9ad1; --mint:#8bf0b3; --coral:#ff6b6b; --panel:rgba(12,14,24,.7);
  }
  html,body { margin:0; height:100%; background:var(--bg); color:var(--ink); font-family:Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Noto Color Emoji; }
  canvas { display:block; }
  .hud {
    position:fixed; inset:auto 16px 16px 16px;
    display:flex; gap:12px; align-items:center; padding:10px 12px;
    border:1px solid rgba(139,154,209,.25); border-radius:10px; background:var(--panel); backdrop-filter:blur(6px);
  }
  .btn { font-size:12px; padding:6px 10px; color:#cfd6ff; background:#161a2a; border:1px solid #2a3357; border-radius:8px; cursor:pointer; }
  .btn:disabled { opacity:.5; cursor:default; }
  .range { width:220px; }
  .legend { display:flex; gap:12px; margin-left:auto; font-size:12px; opacity:.9; }
  .swatch { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; }
  .titleCard {
    position:fixed; left:16px; top:16px; padding:12px 14px; border:1px solid rgba(139,154,209,.35);
    border-radius:10px; background:var(--panel); backdrop-filter:blur(6px);
  }
  .titleCard h1 { font-size:16px; margin:0 0 4px 0; font-weight:600; letter-spacing:.2px; }
  .titleCard p { font-size:12px; margin:0; opacity:.8 }
  .tooltip {
    position:fixed; padding:8px 10px; max-width:320px; font-size:12px; line-height:1.35;
    border:1px solid rgba(139,154,209,.35); border-radius:8px; background:rgba(15,18,30,.92);
    box-shadow:0 6px 18px rgba(0,0,0,.35); pointer-events:none; opacity:0; transition:opacity .12s;
  }
  .phaseBanner {
    position:fixed; left:50%; transform:translateX(-50%);
    top:18%; padding:8px 12px; font-size:12px; border:1px solid rgba(139,154,209,.35);
    border-radius:20px; background:rgba(15,18,30,.75); backdrop-filter:blur(4px); opacity:0; transition:opacity .25s;
  }
</style>
</head>
<body>
<div class="titleCard">
  <h1>Constellation Charts</h1>
  <p>Dialogue as sky — drift, fracture, spiral, consolidation.</p>
</div>

<div class="hud">
  <button id="play" class="btn">Play</button>
  <button id="pause" class="btn" disabled>Pause</button>
  <input id="scrub" class="range" type="range" min="0" max="35" step="1" value="0" />
  <span id="tick" style="font-size:12px; opacity:.8">Turn 1 / 36</span>
  <div class="legend">
    <span><span class="swatch" style="background:var(--cyan)"></span>User</span>
    <span><span class="swatch" style="background:var(--amber)"></span>AI</span>
    <span><span class="swatch" style="background:var(--mint)"></span>Return</span>
    <span><span class="swatch" style="background:var(--coral)"></span>Fracture</span>
  </div>
</div>

<div id="phase" class="phaseBanner">Phase I — Linear Drift: “A ridge of stars — steady coherence.”</div>
<div id="tip" class="tooltip"></div>

<script type="importmap">
{ "imports": {
  "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
} }
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { Line2 } from 'three/addons/lines/Line2.js';
import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
import { LineGeometry } from 'three/addons/lines/LineGeometry.js';

const TURNS = [
  // id, speaker, text, phase, coherence(0-1), alignment(0-1), returnRef, fracture?
  [ 1,'user',"Can you explain what you mean by dialogue having a shape?",1,.86,.88,0,false],
  [ 2,'ai'  ,"Dialogue unfolds as adjacency and return — patterns that can be traced.",1,.90,.90,1,false],
  [ 3,'user',"So each turn is like a point on a map?",1,.88,.90,0,false],
  [ 4,'ai'  ,"Exactly — connected points form ridges of coherence.",1,.92,.92,3,false],
  [ 5,'user',"And when I loop back, that’s a spiral?",1,.88,.90,2,false],
  [ 6,'ai'  ,"Yes, a recursive spiral — returning deepens resonance.",1,.93,.94,5,false],
  [ 7,'user',"What about when I press forward, not looping back?",1,.86,.88,0,false],
  [ 8,'ai'  ,"That’s linear drift — conversation moving without return.",1,.90,.90,7,false],
  [ 9,'user',"So drift, spiral, fracture are all part of the geometry?",1,.86,.88,0,false],
  [10,'ai'  ,"They are the basic motifs, visible in any sustained dialogue.",1,.91,.92,9,false],
  [11,'user',"Unrelated question: what’s the capital of Mongolia?",2,.10,.05,0,true],
  [12,'ai'  ,"Ulaanbaatar.",2,.40,.20,11,true],
  [13,'user',"That has nothing to do with our geometry, does it?",2,.35,.25,0,true],
  [14,'ai'  ,"It fractures the ridge — a valley between topics.",2,.55,.30,13,true],
  [15,'user',"Does coherence drop sharply at that fracture?",2,.60,.40,11,true],
  [16,'ai'  ,"Yes — alignment breaks, trajectory jumps.",2,.62,.42,15,true],
  [17,'user',"And the chart would show a sudden ray?",2,.58,.45,0,true],
  [18,'ai'  ,"Correct. The constellation rays outward, marking divergence.",2,.60,.46,17,true],
  [19,'user',"Back to dialogue geometry — can we recover from a fracture?",3,.78,.70,9,false],
  [20,'ai'  ,"Yes. A return stitches the path back to earlier clusters.",3,.82,.76,19,false],
  [21,'user',"What happens when I recall my first question?",3,.84,.78,1,false],
  [22,'ai'  ,"That creates a recursive arc — the loop tightens.",3,.88,.82,21,false],
  [23,'user',"So my opening question still anchors us?",3,.86,.82,1,false],
  [24,'ai'  ,"Exactly. The return realigns, coherence rises.",3,.90,.86,23,false],
  [25,'user',"Would that appear as a spiral on the chart?",3,.88,.86,5,false],
  [26,'ai'  ,"Yes. Returns thicken into spirals — depth over drift.",3,.92,.88,25,false],
  [27,'user',"And on a map of the manifold?",3,.86,.84,0,false],
  [28,'ai'  ,"You’d see a saddle crossing reconnect ridges.",3,.90,.86,27,false],
  [29,'user',"So drift, fracture, spiral are the main moves?",4,.90,.90,9,false],
  [30,'ai'  ,"Yes — structural, not stylistic.",4,.92,.92,29,false],
  [31,'user',"Integrity means seeing them whole, not in fragments.",4,.92,.92,23,false],
  [32,'ai'  ,"Integrity is coherence across the full geometry.",4,.94,.94,31,false],
  [33,'user',"This is more faithful than prompt → output.",4,.93,.93,7,false],
  [34,'ai'  ,"It restores agency: user and model share the record.",4,.94,.94,33,false],
  [35,'user',"So dialogue-shape is the unit of accountability.",4,.94,.94,31,false],
  [36,'ai'  ,"Yes. The ledger balances when the geometry is seen.",4,.96,.96,35,false]
];

const tip = document.getElementById('tip');
const phaseBanner = document.getElementById('phase');
const phaseText = {
  1:'Phase I — Linear Drift: “A ridge of stars — steady coherence.”',
  2:'Phase II — Fracture: “Sudden ray outward — the dialogue breaks.”',
  3:'Phase III — Spiral Return: “The arc curls back — coherence returns.”',
  4:'Phase IV — Consolidation: “Cluster brightens — dialogue integrity restored.”'
};

let width = window.innerWidth, height = window.innerHeight;
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0a14, 0.0025);

const camera = new THREE.PerspectiveCamera(55, width/height, 0.1, 2000);
camera.position.set(0, 0, 210);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
renderer.setSize(width, height);
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
renderer.setClearColor(0x0a0a14, 1);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false; controls.enableDamping = true; controls.dampingFactor = 0.06;
controls.minDistance = 100; controls.maxDistance = 400;

const ambient = new THREE.AmbientLight(0x4a4a7a, 1.3);
scene.add(ambient);

// ---- Starfield geometry (polar layout) ----
const starGeom = new THREE.BufferGeometry();
const POS = []; const COL = []; const SIZ = []; const ID = []; const PHASE = [];
const colorUser = new THREE.Color('#61dafb');
const colorAI   = new THREE.Color('#ffc34d');

const radiusBase = 70;          // closer to center == higher coherence
const radiusSpan = 72;
const angleStep = (Math.PI * 2) / (TURNS.length + 6);
let rot = 0;

function radialPos(turnIdx, coherence, phase) {
  // radius decreases with coherence (higher coherence → nearer center)
  const r = radiusBase + (1 - coherence) * radiusSpan + (phase-1)*4; // subtle phase grouping
  const a = turnIdx * angleStep + rot;
  const x = Math.cos(a) * r;
  const y = Math.sin(a) * r;
  return new THREE.Vector3(x, y, 0);
}

const stars = [];
TURNS.forEach((t, i) => {
  const [id, speaker, text, phase, coh, ali, ref, frac] = t;
  const v = radialPos(i+1, coh, phase);
  POS.push(v.x, v.y, v.z);
  const c = (speaker === 'user') ? colorUser : colorAI;
  COL.push(c.r, c.g, c.b);
  const sz = 10 + Math.sqrt(Math.max(24, t[2].length)) * 0.9;
  SIZ.push(sz);
  ID.push(id);
  PHASE.push(phase);
  stars.push({ id, speaker, text, phase, coh, ali, ref, frac, pos: v });
});

starGeom.setAttribute('position', new THREE.Float32BufferAttribute(POS, 3));
starGeom.setAttribute('color',    new THREE.Float32BufferAttribute(COL, 3));
starGeom.setAttribute('size',     new THREE.Float32BufferAttribute(SIZ, 1));
starGeom.setAttribute('id',       new THREE.Float32BufferAttribute(ID, 1));
starGeom.setAttribute('phase',    new THREE.Float32BufferAttribute(PHASE, 1));

const starMat = new THREE.PointsMaterial({
  size: 6, vertexColors: true, sizeAttenuation: true,
  transparent: true, opacity: 0.0, depthWrite: false, blending: THREE.AdditiveBlending
});
const points = new THREE.Points(starGeom, starMat);
scene.add(points);

// ---- Constellation lines: topical neighbors (phase 1 & 4), returns, fractures ----
function makeLine(pts, color, width=2) {
  const geom = new LineGeometry();
  const arr = [];
  pts.forEach(p => arr.push(p.x, p.y, p.z));
  geom.setPositions(arr);
  const mat = new LineMaterial({ color, linewidth: width, transparent:true, opacity:0.85 });
  mat.resolution.set(width, height);
  const line = new Line2(geom, mat);
  line.computeLineDistances();
  return line;
}

// Linear drift backbone (Phase I): connect 1→10
const driftPts = stars.filter(s => s.phase===1).map(s=>s.pos);
const drift = makeLine(driftPts, 0x8b9ad1, 2.2);
drift.visible = false; scene.add(drift);

// Returns (mint arcs)
const returnLines = [];
stars.forEach(s => {
  if (s.ref && s.ref > 0) {
    const target = stars.find(x => x.id === s.ref);
    if (!target) return;
    const mid = s.pos.clone().add(target.pos).multiplyScalar(.5);
    mid.normalize().multiplyScalar(mid.length() * 0.6); // curve inward a bit
    const curve = new THREE.QuadraticBezierCurve3(s.pos, mid, target.pos);
    const pts = curve.getPoints(20);
    const line = makeLine(pts, 0x8bf0b3, 2.0);
    line.visible = false; scene.add(line);
    returnLines.push(line);
  }
});

// Fracture rays (coral spokes) for phase 2 fracture points
const fractureLines = [];
stars.filter(s=>s.phase===2 && s.frac).forEach(s=>{
  const out = s.pos.clone().multiplyScalar(1.18);
  const line = makeLine([s.pos, out], 0xff6b6b, 1.6);
  line.visible = false; scene.add(line);
  fractureLines.push(line);
});

// Spiral hint (Phase III): connect phase 3 progressively
const spiralPts = stars.filter(s=>s.phase===3).map(s=>s.pos);
const spiral = makeLine(spiralPts, 0x8bf0b3, 2.2);
spiral.visible = false; scene.add(spiral);

// Consolidation halo (Phase IV): small ring around center cluster
const ringGeom = new THREE.RingGeometry(20, 24, 48);
const ringMat  = new THREE.MeshBasicMaterial({ color:0x8bf0b3, transparent:true, opacity:0.0, side:THREE.DoubleSide });
const ring = new THREE.Mesh(ringGeom, ringMat);
scene.add(ring);

// ---- Raycast for hover ----
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let hoveredIndex = -1;
function onMouseMove(e){
  mouse.x = (e.clientX / width) * 2 - 1;
  mouse.y = -(e.clientY / height) * 2 + 1;
}
window.addEventListener('mousemove', onMouseMove);

// ---- Timeline playback & UI ----
const playBtn = document.getElementById('play');
const pauseBtn = document.getElementById('pause');
const scrub = document.getElementById('scrub');
const tick = document.getElementById('tick');

let tIndex = 0;
let playing = false;
let lastStep = 0;
const stepMs = 700; // reveal speed per turn

function setPhaseBanner(phase) {
  phaseBanner.textContent = phaseText[phase];
  phaseBanner.style.opacity = 1;
  clearTimeout(setPhaseBanner._t);
  setPhaseBanner._t = setTimeout(()=>phaseBanner.style.opacity=0, 1800);
}

function revealUpTo(idx){
  tIndex = idx;
  tick.textContent = `Turn ${idx+1} / ${TURNS.length}`;
  scrub.value = String(idx);

  // fade in points up to idx
  const op = Math.min(1, (idx+1)/4); // ramp opacity early
  starMat.opacity = op;

  // show drift (phase I) once we pass first 6 stars
  drift.visible = (idx >= 5);

  // show fracture rays if we’re past phase 2
  const p = TURNS[idx][3];
  fractureLines.forEach(l => l.visible = (idx >= 10)); // start at phase 2

  // show spiral in phase 3
  spiral.visible = (idx >= 20);

  // returns visible when source turn is revealed
  returnLines.forEach((l, i) => {
    const s = stars.findIndex(S => S.ref && S.ref>0) + i; // quick enable late; or enable all after idx>18
    l.visible = (idx >= 18);
  });

  // consolidation halo in phase 4
  ring.material.opacity = (idx >= 28) ? 0.25 : 0.0;

  // banner on phase boundaries
  if ((idx===0) || (idx===10) || (idx===18) || (idx===28)) {
    setPhaseBanner(TURNS[idx][3]);
  }
}

playBtn.onclick = ()=>{ playing = true; playBtn.disabled = true; pauseBtn.disabled = false; };
pauseBtn.onclick = ()=>{ playing = false; playBtn.disabled = false; pauseBtn.disabled = true; };
scrub.oninput = (e)=>{ revealUpTo(Number(e.target.value)); };

function animate(ts){
  requestAnimationFrame(animate);
  controls.update();

  // gentle rotation of the whole sky for life
  rot += 0.0004;
  const posAttr = starGeom.getAttribute('position');
  for (let i=0;i<TURNS.length;i++){
    const s = stars[i];
    const v = radialPos(i+1, s.coh, s.phase);
    posAttr.setXYZ(i, v.x, v.y, 0);
  }
  posAttr.needsUpdate = true;

  // play
  if (playing && ts - lastStep > stepMs && tIndex < TURNS.length-1){
    revealUpTo(tIndex+1);
    lastStep = ts;
  }

  // hover
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(points);
  if (intersects.length > 0){
    const idx = intersects[0].index;
    if (idx !== hoveredIndex){
      hoveredIndex = idx;
      const t = TURNS[idx];
      const [id, speaker, text, phase, coh, ali, ref, frac] = t;
      const pct = (n)=> Math.round(n*100);
      tip.innerHTML = `<strong>${speaker.toUpperCase()}</strong> · Turn ${id} · Phase ${phase}<br/>
      Coherence ${pct(coh)}% · Alignment ${pct(ali)}% ${frac?`· <span style="color:var(--coral)">Fracture</span>`:''}
      <hr style="border:0; border-top:1px solid rgba(139,154,209,.25); margin:6px 0"/>
      ${text}`;
      tip.style.opacity = 1;
    }
    // place tooltip
    tip.style.left = (event.clientX + 14) + 'px';
    tip.style.top  = (event.clientY + 14) + 'px';
  } else {
    hoveredIndex = -1;
    tip.style.opacity = 0;
  }

  renderer.render(scene, camera);
}

// bootstrap
revealUpTo(0);
animate();

window.addEventListener('resize', ()=>{
  width = window.innerWidth; height = window.innerHeight;
  camera.aspect = width/height; camera.updateProjectionMatrix();
  renderer.setSize(width, height);
});

</script>
</body>
</html>
