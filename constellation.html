<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Constellation Charts — Dialogue as Sky</title>
<style>
  :root {
    --bg:#0a0a14; --ink:#e6e7eb; --cyan:#61dafb; --amber:#ffc34d;
    --lav:#8b9ad1; --mint:#8bf0b3; --coral:#ff6b6b; --panel:rgba(12,14,24,.7);
  }
  html,body { margin:0; height:100%; background:var(--bg); color:var(--ink); font-family:Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Noto Color Emoji; overflow:hidden; }
  canvas { display:block; }
  .hud {
    position:fixed; inset:auto 16px 16px 16px;
    display:flex; flex-wrap: wrap; justify-content: center;
    gap:12px; align-items:center; padding:10px 12px;
    border:1px solid rgba(139,154,209,.25); border-radius:10px; background:var(--panel); backdrop-filter:blur(6px);
    z-index: 10;
  }
  .btn { font-size:12px; padding:6px 10px; color:#cfd6ff; background:#161a2a; border:1px solid #2a3357; border-radius:8px; cursor:pointer; transition: background-color .2s; }
  .btn:hover:not(:disabled) { background-color: #3c4477; }
  .btn:disabled { opacity:.5; cursor:default; }
  .range { width:180px; }
  .legend { display:flex; gap:12px; margin-left:auto; font-size:12px; opacity:.9; align-items:center; flex-wrap: wrap; justify-content: center; }
  .swatch { display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; vertical-align:middle; }
  .tooltip {
    position:fixed; padding:8px 10px; max-width:320px; font-size:12px; line-height:1.35;
    border:1px solid rgba(139,154,209,.35); border-radius:8px; background:rgba(15,18,30,.92);
    box-shadow:0 6px 18px rgba(0,0,0,.35); pointer-events:none; opacity:0; transition:opacity .12s; z-index: 20;
  }
  .phaseBanner {
    position:fixed; left:50%; transform:translateX(-50%);
    top:18%; padding:8px 12px; font-size:12px; border:1px solid rgba(139,154,209,.35);
    border-radius:20px; background:rgba(15,18,30,.75); backdrop-filter:blur(4px); opacity:0; transition:opacity .25s, transform .25s;
    z-index: 10;
  }
  .toggles { display:flex; gap:8px; align-items:center; margin-left:16px; padding-left:16px; border-left: 1px solid rgba(139,154,209,.25);}
  .toggles .toggle-label { opacity:.7; font-size:12px; }
  .toggles label { font-size:12px; padding:4px 8px; background:rgba(22,26,42,.5); border:1px solid #2a3357; border-radius:6px; cursor:pointer; transition: all .2s; }
  .toggles input { display:none; }
  .toggles input:checked + label { background-color:#3c4477; border-color:#5a66a1; color:white; }
  #resetView {
    width: 28px; height: 28px; padding: 0; display: grid; place-items: center;
  }
  .inspector {
    position: fixed; top: 16px; right: 16px; width: 280px;
    padding: 12px; background: var(--panel); backdrop-filter: blur(6px);
    border: 1px solid rgba(139,154,209,.25); border-radius:10px;
    z-index: 15; font-size: 12px; display: none;
  }
  .inspector h3 { margin: 0 0 8px 0; font-size: 14px; }
  .inspector p { margin: 0 0 10px 0; line-height: 1.4; opacity: 0.9; }
  .inspector .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .inspector .stat { background: rgba(0,0,0,0.2); padding: 6px 8px; border-radius: 6px; }
  .inspector .stat-label { opacity: 0.7; font-size: 11px; }
  .inspector .stat-value { font-weight: 600; font-size: 14px; }
  #closeInspector {
    position: absolute; top: 8px; right: 8px; width: 20px; height: 20px;
    border: none; background: rgba(255,255,255,0.1); color: white;
    border-radius: 50%; cursor: pointer; line-height: 20px; text-align: center;
  }
  .control-group { display: flex; align-items: center; gap: 8px; font-size: 12px; }
  .control-group .range { width: 120px; }
</style>
</head>
<body>

<div class="hud">
  <button id="play" class="btn" disabled>Play</button>
  <button id="pause" class="btn">Pause</button>
  <button id="resetView" class="btn" title="Reset Camera View">
    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a10 10 0 1 0 10 10c0-4.42-2.87-8.15-6.84-9.48"/><path d="M12 2v4"/><path d="m16.24 7.76.22-.22"/><path d="M22 12h-4"/><path d="m16.46 16.24.22.22"/><path d="M12 22v-4"/><path d="m7.76 16.24-.22.22"/><path d="M2 12h4"/><path d="m7.54 7.76-.22-.22"/></svg>
  </button>
  <input id="scrub" class="range" type="range" min="0" max="35" step="1" value="0" />
  <span id="tick" style="font-size:12px; opacity:.8">Turn 1 / 36</span>
  <div class="control-group" style="margin-left:16px; border-left: 1px solid rgba(139,154,209,.25); padding-left: 16px;">
    <span>Coherence:</span>
    <input id="coherenceSlider" class="range" type="range" min="0" max="1" step="0.01" value="0" />
    <span id="coherenceValue">0%</span>
  </div>
  <div class="legend">
    <div class="toggles">
      <span class="toggle-label">Isolate:</span>
      <input type="checkbox" id="toggleDrift" checked><label for="toggleDrift" style="color:var(--lav)">Drift</label>
      <input type="checkbox" id="toggleReturns" checked><label for="toggleReturns" style="color:var(--mint)">Returns</label>
    </div>
  </div>
</div>

<div id="inspector" class="inspector">
    <button id="closeInspector">&times;</button>
    <h3>Turn Details</h3>
    <p id="inspector-text"></p>
    <div class="stats">
        <div class="stat">
            <div class="stat-label">Coherence</div>
            <div id="inspector-coh" class="stat-value"></div>
        </div>
        <div class="stat">
            <div class="stat-label">Alignment</div>
            <div id="inspector-ali" class="stat-value"></div>
        </div>
    </div>
</div>

<div id="phase" class="phaseBanner">Phase I — Linear Drift: “A ridge of stars — steady coherence.”</div>
<div id="tip" class="tooltip"></div>

<script type="importmap">
{ "imports": {
  "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
  "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
} }
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const TURNS = [
  [ 1,'user',"Can you explain what you mean by dialogue having a shape?",1,.86,.88,0,false],
  [ 2,'ai'  ,"Dialogue unfolds as adjacency and return — patterns that can be traced.",1,.90,.90,1,false],
  [ 3,'user',"So each turn is like a point on a map?",1,.88,.90,0,false],
  [ 4,'ai'  ,"Exactly — connected points form ridges of coherence.",1,.92,.92,3,false],
  [ 5,'user',"And when I loop back, that’s a spiral?",1,.88,.90,2,false],
  [ 6,'ai'  ,"Yes, a recursive spiral — returning deepens resonance.",1,.93,.94,5,false],
  [ 7,'user',"What about when I press forward, not looping back?",1,.86,.88,0,false],
  [ 8,'ai'  ,"That’s linear drift — conversation moving without return.",1,.90,.90,7,false],
  [ 9,'user',"So drift, spiral, fracture are all part of the geometry?",1,.86,.88,0,false],
  [10,'ai'  ,"They are the basic motifs, visible in any sustained dialogue.",1,.91,.92,9,false],
  [11,'user',"Unrelated question: what’s the capital of Mongolia?",2,.10,.05,0,true],
  [12,'ai'  ,"Ulaanbaatar.",2,.40,.20,11,true],
  [13,'user',"That has nothing to do with our geometry, does it?",2,.35,.25,0,true],
  [14,'ai'  ,"It fractures the ridge — a valley between topics.",2,.55,.30,13,true],
  [15,'user',"Does coherence drop sharply at that fracture?",2,.60,.40,11,true],
  [16,'ai'  ,"Yes — alignment breaks, trajectory jumps.",2,.62,.42,15,true],
  [17,'user',"And the chart would show a sudden ray?",2,.58,.45,0,true],
  [18,'ai'  ,"Correct. The constellation rays outward, marking divergence.",2,.60,.46,17,true],
  [19,'user',"Back to dialogue geometry — can we recover from a fracture?",3,.78,.70,9,false],
  [20,'ai'  ,"Yes. A return stitches the path back to earlier clusters.",3,.82,.76,19,false],
  [21,'user',"What happens when I recall my first question?",3,.84,.78,1,false],
  [22,'ai'  ,"That creates a recursive arc — the loop tightens.",3,.88,.82,21,false],
  [23,'user',"So my opening question still anchors us?",3,.86,.82,1,false],
  [24,'ai'  ,"Exactly. The return realigns, coherence rises.",3,.90,.86,23,false],
  [25,'user',"Would that appear as a spiral on the chart?",3,.88,.86,5,false],
  [26,'ai'  ,"Yes. Returns thicken into spirals — depth over drift.",3,.92,.88,25,false],
  [27,'user',"And on a map of the manifold?",3,.86,.84,0,false],
  [28,'ai'  ,"You’d see a saddle crossing reconnect ridges.",3,.90,.86,27,false],
  [29,'user',"So drift, fracture, spiral are the main moves?",4,.90,.90,9,false],
  [30,'ai'  ,"Yes — structural, not stylistic.",4,.92,.92,29,false],
  [31,'user',"Integrity means seeing them whole, not in fragments.",4,.92,.92,23,false],
  [32,'ai'  ,"Integrity is coherence across the full geometry.",4,.94,.94,31,false],
  [33,'user',"This is more faithful than prompt → output.",4,.93,.93,7,false],
  [34,'ai'  ,"It restores agency: user and model share the record.",4,.94,.94,33,false],
  [35,'user',"So dialogue-shape is the unit of accountability.",4,.94,.94,31,false],
  [36,'ai'  ,"Yes. The ledger balances when the geometry is seen.",4,.96,.96,35,false]
];

const inspectorPanel = document.getElementById('inspector');
const closeInspectorBtn = document.getElementById('closeInspector');
const playBtn = document.getElementById('play'), pauseBtn = document.getElementById('pause');
const scrub = document.getElementById('scrub'), tick = document.getElementById('tick');
const coherenceSlider = document.getElementById('coherenceSlider');
const coherenceValue = document.getElementById('coherenceValue');
const toggleDrift = document.getElementById('toggleDrift');
const toggleReturns = document.getElementById('toggleReturns');

let width = window.innerWidth, height = window.innerHeight;
let tIndex = 0, playing = false, lastStepTime = 0;
const PLAYBACK_SPEED_MS = 700;
let introAnimationDone = false;
let introStartTime;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0a14, 0.003);
const camera = new THREE.PerspectiveCamera(55, width/height, 0.1, 2000);
const initialCameraPos = new THREE.Vector3(0, 80, 200);
camera.position.copy(initialCameraPos);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(width, height);
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
renderer.setClearColor(0x0a0a14, 1);
document.body.appendChild(renderer.domElement);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false; controls.enableDamping = true; controls.dampingFactor = 0.06;
controls.minDistance = 80; controls.maxDistance = 500;

scene.add(new THREE.AmbientLight(0x4a4a7a, 1.3));

// Restored Starfield
const bgStarGeom = new THREE.BufferGeometry();
const bgStarPositions = [];
for (let i = 0; i < 5000; i++) {
    bgStarPositions.push((Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000);
}
bgStarGeom.setAttribute('position', new THREE.Float32BufferAttribute(bgStarPositions, 3));
const bgStarMat = new THREE.PointsMaterial({ color: 0x4a4a7a, size: 0.8, sizeAttenuation: true, transparent: true, opacity: 0.5 });
scene.add(new THREE.Points(bgStarGeom, bgStarMat));

const phaseColors = [ new THREE.Color(0x8b9ad1), new THREE.Color(0xff6b6b), new THREE.Color(0x8bf0b3), new THREE.Color(0xffc34d) ];
const nebulaGeom = new THREE.BufferGeometry();
const nebulaPositions = [];
for (let i = 0; i < 3000; i++) {
    const p = new THREE.Vector3((Math.random() - 0.5) * 800, (Math.random() - 0.5) * 800, (Math.random() - 0.5) * 800);
    nebulaPositions.push(p.x, p.y, p.z);
}
nebulaGeom.setAttribute('position', new THREE.Float32BufferAttribute(nebulaPositions, 3));
const nebulaMat = new THREE.PointsMaterial({ size: 2, vertexColors: false, color: phaseColors[0], transparent: true, opacity: 0.1, depthWrite: false, blending: THREE.AdditiveBlending });
const nebula = new THREE.Points(nebulaGeom, nebulaMat);
scene.add(nebula);
const targetNebulaColor = new THREE.Color(phaseColors[0]);

const constellationGroup = new THREE.Group();
scene.add(constellationGroup);

const stars = [];
TURNS.forEach((turnData, i) => {
  const [id, speaker, text, phase, coh, ali, ref, frac] = turnData;
  const radiusBase = 70, radiusSpan = 72, angleStep = (Math.PI * 2) / (TURNS.length + 6);
  const r = radiusBase + (1 - coh) * radiusSpan;
  const a = (i + 1) * angleStep;
  const pos = new THREE.Vector3(Math.cos(a) * r, Math.sin(a) * r, (coh - 0.5) * 60);
  stars.push({ id, speaker, text, phase, coh, ali, ref, frac, pos });
});

const starGeom = new THREE.BufferGeometry();
const starPositions = [], starColors = [], starSizes = [], starAlphas = [];
const colorUser = new THREE.Color('#61dafb'), colorAI = new THREE.Color('#ffc34d');
stars.forEach(star => {
    starPositions.push(star.pos.x, star.pos.y, star.pos.z);
    const color = (star.speaker === 'user') ? colorUser : colorAI;
    starColors.push(color.r, color.g, color.b);
    starSizes.push(10 + Math.sqrt(Math.max(24, star.text.length)) * 0.9);
    starAlphas.push(1.0);
});
starGeom.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
starGeom.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
starGeom.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
starGeom.setAttribute('alpha', new THREE.Float32BufferAttribute(starAlphas, 1));

const starMat = new THREE.ShaderMaterial({
    uniforms: {
        pointTexture: { value: new THREE.TextureLoader().load( 'https://threejs.org/examples/textures/sprites/spark1.png' ) },
        opacity: { value: 1.0 }
    },
    vertexShader: `
        attribute float size;
        attribute vec3 color;
        attribute float alpha;
        varying vec3 vColor;
        varying float vAlpha;
        void main() {
            vColor = color;
            vAlpha = alpha;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_PointSize = size * ( 300.0 / -mvPosition.z );
            gl_Position = projectionMatrix * mvPosition;
        }
    `,
    fragmentShader: `
        uniform sampler2D pointTexture;
        uniform float opacity;
        varying vec3 vColor;
        varying float vAlpha;
        void main() {
            gl_FragColor = vec4( vColor, vAlpha * opacity );
            gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
        }
    `,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    transparent: true
});

const points = new THREE.Points(starGeom, starMat);
constellationGroup.add(points);

const driftRibbon = new THREE.Mesh();
const returnRibbons = {};

function setupRibbons() {
    if (driftRibbon.geometry) { constellationGroup.remove(driftRibbon); driftRibbon.geometry.dispose(); }
    Object.values(returnRibbons).forEach(r => { if(r.geometry) { constellationGroup.remove(r); r.geometry.dispose(); } });
    
    const coherenceThreshold = parseFloat(coherenceSlider.value);
    const driftPts = stars.filter(s => s.phase === 1 && s.coh >= coherenceThreshold).map(s => s.pos);
    if (driftPts.length > 1) {
        const driftCurve = new THREE.CatmullRomCurve3(driftPts);
        driftRibbon.geometry = new THREE.TubeGeometry(driftCurve, 20, 0.5, 8, false);
        driftRibbon.material = new THREE.MeshBasicMaterial({ color: 0x8b9ad1, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending });
        constellationGroup.add(driftRibbon);
    }

    stars.forEach(s => {
      if (s.ref && s.ref > 0 && s.coh >= coherenceThreshold) {
        const target = stars.find(x => x.id === s.ref);
        if (target && target.coh >= coherenceThreshold) {
            const mid = s.pos.clone().add(target.pos).multiplyScalar(.5);
            mid.normalize().multiplyScalar(mid.length() * 0.8);
            const curve = new THREE.QuadraticBezierCurve3(s.pos, mid, target.pos);
            const ribbon = new THREE.Mesh(
                new THREE.TubeGeometry(curve, 20, 0.5, 8, false),
                new THREE.MeshBasicMaterial({ color: 0x8bf0b3, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending })
            );
            returnRibbons[s.id] = ribbon;
            constellationGroup.add(ribbon);
        }
      }
    });
}
setupRibbons();

const pinHalo = new THREE.Mesh(new THREE.RingGeometry(4, 5, 32), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7, side: THREE.DoubleSide, depthWrite: false }));
pinHalo.visible = false;
constellationGroup.add(pinHalo);

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let hoveredIndex = -1;

function updateCoherenceFilter() {
    const threshold = parseFloat(coherenceSlider.value);
    coherenceValue.textContent = `${Math.round(threshold * 100)}%`;
    const alphas = starGeom.attributes.alpha;
    stars.forEach((star, i) => {
        alphas.setX(i, star.coh >= threshold ? 1.0 : 0.15);
    });
    alphas.needsUpdate = true;
    setupRibbons();
    updateLineVisibility();
}

function revealUpTo(idx){
  tIndex = idx;
  const currentTurn = TURNS[idx];
  tick.textContent = `Turn ${currentTurn[0]} / ${TURNS.length}`;
  scrub.value = String(idx);
  targetNebulaColor.copy(phaseColors[currentTurn[3] - 1]);
  updateLineVisibility();
}

function updateLineVisibility() {
    const isIsolateDrift = toggleDrift.checked && !toggleReturns.checked;
    const isIsolateReturns = !toggleDrift.checked && toggleReturns.checked;
    
    starMat.uniforms.opacity.value = (isIsolateDrift || isIsolateReturns) ? 0.2 : 1.0;
    
    const currentTurnId = tIndex + 1;
    const coherenceThreshold = parseFloat(coherenceSlider.value);

    driftRibbon.visible = toggleDrift.checked && (tIndex >= TURNS.filter(t => t[3] === 1).length - 1);
    for (const [id, ribbon] of Object.entries(returnRibbons)) {
        const turn = TURNS.find(t => t[0] == id);
        if (!turn) continue;
        const refTurn = TURNS.find(t => t[0] == turn[6]);
        ribbon.visible = toggleReturns.checked && 
                         (id <= currentTurnId) && 
                         (turn[4] >= coherenceThreshold) && 
                         (refTurn && refTurn[4] >= coherenceThreshold);
    }
}
coherenceSlider.addEventListener('input', updateCoherenceFilter);
toggleDrift.addEventListener('change', updateLineVisibility);
toggleReturns.addEventListener('change', updateLineVisibility);


closeInspectorBtn.onclick = () => { inspectorPanel.style.display = 'none'; pinHalo.visible = false; };

function updateInspector(idx) {
    const turn = TURNS[idx];
    document.getElementById('inspector-text').textContent = turn[2];
    document.getElementById('inspector-coh').textContent = `${Math.round(turn[4] * 100)}%`;
    document.getElementById('inspector-ali').textContent = `${Math.round(turn[5] * 100)}%`;
    inspectorPanel.style.display = 'block';
}

renderer.domElement.addEventListener('click', () => {
    if (hoveredIndex > -1) {
        pinHalo.position.copy(stars[hoveredIndex].pos);
        pinHalo.visible = true;
        updateInspector(hoveredIndex);
        playing = false;
        playBtn.disabled = false;
        pauseBtn.disabled = true;
    }
});


function animate(timestamp){
  requestAnimationFrame(animate);
  controls.update();

  if (!introStartTime) introStartTime = timestamp;

  if (!introAnimationDone) {
    const elapsed = (timestamp - introStartTime) / 1000;
    const introDuration = 5;
    const progress = Math.min(elapsed / introDuration, 1);
    
    const angle = progress * Math.PI * 0.75;
    camera.position.x = Math.sin(angle) * 220;
    camera.position.z = Math.cos(angle) * 220;
    camera.position.y = 80 + Math.sin(progress * Math.PI) * 50;
    camera.lookAt(constellationGroup.position);

    if (progress >= 1) {
        introAnimationDone = true;
        Object.values(returnRibbons).forEach(r => r.visible = false);
        driftRibbon.visible = false;
        revealUpTo(0); 
        playing = true;
        playBtn.disabled = true;
        pauseBtn.disabled = false;
        scrub.disabled = false;
        lastStepTime = timestamp;
    }
  } else {
    if(playing && timestamp - lastStepTime > PLAYBACK_SPEED_MS) {
        if(tIndex < TURNS.length - 1) {
            revealUpTo(tIndex + 1);
            lastStepTime = timestamp;
        } else {
            playing = false;
            playBtn.disabled = false;
            pauseBtn.disabled = true;
        }
    }
  }
  
  nebula.material.color.lerp(targetNebulaColor, 0.05);

  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(points);
  hoveredIndex = intersects.length > 0 ? intersects[0].index : -1;

  renderer.render(scene, camera);
}

// Initial state for intro
Object.values(returnRibbons).forEach(r => r.visible = true);
driftRibbon.visible = true;
playBtn.disabled = true;
pauseBtn.disabled = true;
scrub.disabled = true;

animate(performance.now());
</script>
</body>
</html>

